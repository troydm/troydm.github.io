<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: memory | Troydm's Blog]]></title>
  <link href="http://troydm.github.io/blog/categories/memory/atom.xml" rel="self"/>
  <link href="http://troydm.github.io/"/>
  <updated>2022-07-19T17:34:17+04:00</updated>
  <id>http://troydm.github.io/</id>
  <author>
    <name><![CDATA[Dmitry Geurkov]]></name>
    <email><![CDATA[d.geurkov@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Of All The Garbage in The World]]></title>
    <link href="http://troydm.github.io/blog/2015/09/06/of-all-the-garbage-in-the-world/"/>
    <updated>2015-09-06T00:01:19+04:00</updated>
    <id>http://troydm.github.io/blog/2015/09/06/of-all-the-garbage-in-the-world</id>
    <content type="html"><![CDATA[<p>TL;DR <em>Writing tri-color (actually 4-color) incremental generational garbage collector in C</em></p>

<p><a href="http://troydm.github.io/blog/2015/08/03/lifting-shadows-off-a-memory-allocation/">Previously</a> we&rsquo;ve talked about manual memory allocation and unraveled some shadows around it.
Now let&rsquo;s talk about automatic memory allocation, more specifically about <a href="https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29">Garbage Collection</a>.
Most if not all modern Programming Languages contain a mechanism that handles allocation of memory automatically at precisely the moment application needs it and deallocation of that
memory at the moment it&rsquo;s not needed anymore. However determining when memory region (or object) is safe to deallocate is not an easy feat as we need to somehow determine if the region is needed or not.
And here is where <em>Garbage Collection</em> comes into a play. Simply speaking <em>Garbage Collection</em> is an algorithm that checks entire memory of an application for regions that aren&rsquo;t referenced anywhere inside application by other memory regions and deallocates these regions because they aren&rsquo;t needed anymore.</p>

<p><img src="http://i.imgur.com/v5Czgfd.png" alt="Space Dandy" /></p>

<!--more-->


<p><em>Garbage Collection</em> was invented by <a href="https://en.wikipedia.org/wiki/John_McCarthy_%28computer_scientist%29">John McCarthy</a> back in 1959 for <a href="https://en.wikipedia.org/wiki/Lisp_%28programming_language%29">Lisp</a> and is still one of the hottest evolving topics in Computer Science nowadays, especially with <a href="https://en.wikipedia.org/wiki/Java_%28software_platform%29">Java</a>&rsquo;s GC becoming more famous with tons of blows and whistles which can be tuned to practically any application memory usage scenario. There are also alternative models to automatic memory handling such as <a href="https://en.wikipedia.org/wiki/NewLISP">newLisp</a>&rsquo;s ORO, <a href="https://en.wikipedia.org/wiki/Rust_%28programming_language%29">Rust</a>&rsquo;s ownership based life cycle management and <a href="https://en.wikipedia.org/wiki/Objective-C">Objective-C</a>&rsquo;s ARC but we won&rsquo;t be talking about those. The cost of checking entire memory region is not a cheap one so people realized ways to make it more reasonable and thus nowadays we have various types of <em>Garbage Collection</em> algorithms. There are tracing garbage collectors and reference counting ones, copying (moving) and non-copying (non-moving) ones, incremental and non-incremental, generational, concurrent, parallel and real-time ones. To learn more about all those types of <em>Garbage Collectors</em> I suggest you try reading <a href="http://www.amazon.com/Garbage-Collection-Handbook-Management-Algorithms/dp/1420082795/">The Garbage Collection Handbook</a> which is a fundamental must read handbook for all those interested in the topic. But for rest of you lazy bunch let&rsquo;s start collecting all the garbage in the world by writing one garbage collector ourselves.</p>

<p>Let&rsquo;s write a single threaded tracing tri-color (actually 4-color, I&rsquo;ll explain later why) non-copying incremental n-generational (n-generational meaning that we can configure any number of generations dynamically on startup, but our implementation will have limitation of maximum 64 generations) <em>Garbage Collector</em> in <em>C</em>. We won&rsquo;t tackle multithreading, concurrency and parallel garbage collection for sake of simplicity as those are more complex to implement but maybe I&rsquo;ll do another blog post about them later this year. Our simple garbage collector will be single threaded only, meaning it will correctly work only in applications that don&rsquo;t use multiple threads or somehow allocate memory in parallel. This kind of <em>Garbage Collector</em> is sufficient for languages that aren&rsquo;t natively multithreaded, such as <a href="https://en.wikipedia.org/wiki/Node.js">Node.js</a> and <a href="https://en.wikipedia.org/wiki/Pharo">Pharo</a>, so if you are planning to write such language yourself this might be a useful exercise for you. For those of you impatient ones there is a <a href="https://github.com/troydm/simplegc/">simplegc</a> repo with all the source code to study. So let&rsquo;s get started.</p>

<p>We need a way to represent our memory regions so we&rsquo;ll go for the most obvious object oriented representation, meaning we&rsquo;ll just write a garbage collector for object-oriented programming language of ours.
Each object will be part of doubly linked list so we could trace it and hence it will contain a pointer to a pointer of a previous object pointing to it called <strong>gc_prev</strong> and a pointer to the next object called <strong>gc_next</strong>.
Each object will have a pointer to a <strong>class</strong> description which we&rsquo;ll talk about later.
Each object will also have 32-bit unsigned integer called <strong>gc_mark</strong> which will serve three purposes: to mark object&rsquo;s color, gc generation and count root references (I&rsquo;ll explain those later). Each object might also reference other objects for example we might have fields inside object which could contain other objects so hence we need <strong>refs_count</strong> variable to count number of fields object has.
Since each object will be of a class we also need to represent the class itself. It will contain function pointers that will be used during garbage collection. One of them is the most obvious function pointer which is a <strong>gc_finalize</strong> function. This function will be called precisely before the moment of freeing memory region which is not used anymore or simply speaking just before the object will be deleted by the <em>Garbage Collector</em>. <strong>gc_mark_black</strong> function pointer will point to a function used to mark object from <em>grey</em> to <em>black</em> and mark all objects it&rsquo;s referring (or contains) as <em>grey</em> for further processing. <strong>gc_contains</strong> will be a function used to check if an object is referenced (or contained) by another object.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">gc_object_class_t</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// gc object</span>
</span><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">gc_object_t</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">struct</span> <span class="n">gc_object_t</span><span class="o">**</span> <span class="n">gc_prev</span><span class="p">;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">gc_object_t</span><span class="o">*</span> <span class="n">gc_next</span><span class="p">;</span>
</span><span class='line'><span class="kt">uint32_t</span> <span class="n">gc_mark</span><span class="p">;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">gc_object_class_t</span><span class="o">*</span> <span class="n">class</span><span class="p">;</span>
</span><span class='line'><span class="kt">uint16_t</span> <span class="n">refs_count</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span> <span class="n">gc_object</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// gc object class</span>
</span><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">gc_object_class_t</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">gc_mark_black</span><span class="p">)(</span><span class="n">gc_object</span><span class="o">*</span> <span class="n">obj</span><span class="p">);</span> <span class="c1">// this marks  object from grey to black</span>
</span><span class='line'><span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">gc_contains</span><span class="p">)(</span><span class="n">gc_object</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">gc_object</span><span class="o">*</span> <span class="n">ref</span><span class="p">);</span> <span class="c1">// this checks if object contains reference object</span>
</span><span class='line'><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">gc_finalize</span><span class="p">)(</span><span class="n">gc_object</span><span class="o">*</span> <span class="n">obj</span><span class="p">);</span> <span class="c1">// this is called before object is deallocated</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span> <span class="n">gc_object_class</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Now let&rsquo;s talk about <strong>gc_mark</strong>. As I&rsquo;ve said earlier it&rsquo;ll serve three purposes for our object: root reference count, object&rsquo;s color marking, and gc generation.
We&rsquo;ll use first 24 bits for root reference counting, next 2 bits will be used for color (as we&rsquo;ll have 4 possible colors we need 2 bits since 2<sup>2</sup> is 4) and remaining 6 bits will be used for gc generation (meaning we can&rsquo;t have more than 64 generations since 2<sup>6</sup> is 64, but that is enough for any use case).</p>

<p><canvas id="gc_mark" width="400" height="75"></canvas></p>

<script>
function drawRect(ctx,text,x,y,w,h){
    ctx.fillRect(x,y,w,h);
    ctx.moveTo(x,y);
    ctx.lineTo(x,y+h);
    ctx.stroke();
    ctx.moveTo(x,y);
    ctx.lineTo(x+w,y);
    ctx.stroke();
    ctx.moveTo(x+w,y);
    ctx.lineTo(x+w,y+h);
    ctx.stroke();
    ctx.moveTo(x,y+h);
    ctx.lineTo(x+w,y+h);
    ctx.stroke();
    var fs = ctx.fillStyle;
    ctx.fillStyle = "#000000";
    var tl = 16*text.length;
    ctx.fillText(text,x+(w/2)-(tl/4)+5,y+(h/2)+4);
    ctx.fillStyle = fs;
}
var c = document.getElementById("gc_mark");
var ctx = c.getContext("2d");
ctx.font="normal 12pt Sans";
ctx.fillStyle = "#000000";
ctx.fillText("gc_mark (32-bit unsigned integer)",5,15);
ctx.fillStyle = "#F8D7BB";
ctx.strokeStyle = "#000000";
drawRect(ctx,"24 bits",0,20,300,35);
drawRect(ctx," 2 bits",300,20,50,35);
drawRect(ctx," 6 bits",350,20,50,35);
ctx.fillStyle = "#000000";
ctx.fillText("root reference count",95,70);
ctx.fillText("color",310,70);
ctx.fillText("gen",365,70);
</script>


<p>Let&rsquo;s define some useful macros to work with <strong>gc_mark</strong>. Most of them are related to bitwise magic so I won&rsquo;t explain them in details but instead leave that as self-study for you.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// gc mark&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">gc_set_mark</span><span class="p">(</span><span class="n">o</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">gi</span><span class="p">)</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">gc_mark</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">gi</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// generation part&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">gc_gen_part</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">gc_mark</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="mh">0xFF</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">gc_gen_num</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">gc_mark</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="mh">0x3F</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">gc_gen_set</span><span class="p">(</span><span class="n">o</span><span class="p">,</span><span class="n">g</span><span class="p">)</span> <span class="n">gc_set_mark</span><span class="p">(</span><span class="n">o</span><span class="p">,</span><span class="n">gc_root_ref_count</span><span class="p">(</span><span class="n">o</span><span class="p">),</span> <span class="n">gc_color_bit</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">g</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="mh">0x3F</span><span class="p">))</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// color bits&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">gc_color_bit</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">gc_mark</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="mh">0xC0</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">gc_color</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="p">(</span><span class="n">gc_gen_part</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">gc_color_is_white</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="p">(</span><span class="n">gc_color_bit</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x00</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">gc_color_is_grey</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="p">(</span><span class="n">gc_color_bit</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x40</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">gc_color_is_black</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="p">(</span><span class="n">gc_color_bit</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x80</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">gc_color_is_silver</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="p">(</span><span class="n">gc_color_bit</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xC0</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">gc_color_is_silver_or_white</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="p">(</span><span class="n">gc_color_is_silver</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">||</span> <span class="n">gc_color_is_white</span><span class="p">(</span><span class="n">o</span><span class="p">))</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">gc_mark_white</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">gc_mark</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">=</span> <span class="mh">0xFFFFFF3F</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">gc_mark_grey</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="n">gc_mark_white</span><span class="p">(</span><span class="n">o</span><span class="p">);</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">gc_mark</span> <span class="o">|=</span> <span class="mh">0x40</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">gc_mark_black</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="n">gc_mark_white</span><span class="p">(</span><span class="n">o</span><span class="p">);</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">gc_mark</span> <span class="o">|=</span> <span class="mh">0x80</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">gc_mark_silver</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">gc_mark</span> <span class="o">|=</span> <span class="mh">0xC0</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// root reference count&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">gc_root_ref_count</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">gc_mark</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">gc_inc_root_ref_count</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="n">gc_set_mark</span><span class="p">(</span><span class="n">o</span><span class="p">,(</span><span class="n">gc_root_ref_count</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">gc_gen_part</span><span class="p">(</span><span class="n">o</span><span class="p">))</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">gc_dec_root_ref_count</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="n">gc_set_mark</span><span class="p">(</span><span class="n">o</span><span class="p">,(</span><span class="n">gc_root_ref_count</span><span class="p">(</span><span class="n">o</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">gc_gen_part</span><span class="p">(</span><span class="n">o</span><span class="p">))</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Now let&rsquo;s describe configuration for our garbage collector. First thing first we need to limit duration
of our garbage collection cycle since we don&rsquo;t want it to be too long and are writing an incremental garbage
collector after all. For this we&rsquo;ll have <strong>max_pause</strong> configuration property which will define maximum amount of
nanoseconds gc cycle can run. Also since we need to somehow check if our cycle is exceeding it&rsquo;s pause limit or not
we just can&rsquo;t do it after every object we check during gc cycle, thus we need <strong>pause_threshold</strong> which is number of
objects checked after which gc pause check occurs. Next we define number of generations our garbage collector will have
using <strong>gens_count</strong> and provide generation configurations array using <strong>gens</strong>.
Each generation configuration will have <strong>refresh_interval</strong> which is number of nanoseconds passed after last full gc cycle
after which entire generation of objects should be rechecked. Now we need to clarify what is full gc cycle.
Full gc cycle is garbage collection cycle that is not interrupted after hitting max pause threshold.
Last thing our generation configuration has is <strong>promotion_interval</strong> which is number of nanoseconds passed after last full gc cycle
after which our objects in generation are promoted to higher generation. This configuration property is not relevant for the last generation since there is no next generation to promote to.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// gc config</span>
</span><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">uint64_t</span> <span class="n">max_pause</span><span class="p">;</span> <span class="c1">// gc max pause in nanoseconds</span>
</span><span class='line'><span class="kt">uint32_t</span> <span class="n">pause_threshold</span><span class="p">;</span> <span class="c1">// number of objects checked after which gc pause check should occur</span>
</span><span class='line'><span class="kt">uint8_t</span> <span class="n">gens_count</span><span class="p">;</span> <span class="c1">// number of generations</span>
</span><span class='line'><span class="n">gc_gen_config</span><span class="o">*</span> <span class="n">gens</span><span class="p">;</span> <span class="c1">// generation configs array</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span> <span class="n">gc_config</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// generation config</span>
</span><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">uint64_t</span> <span class="n">refresh_interval</span><span class="p">;</span> <span class="c1">// generation refresh interval in nanoseconds</span>
</span><span class='line'><span class="kt">uint64_t</span> <span class="n">promotion_interval</span><span class="p">;</span> <span class="c1">// generation promotion interval in nanoseconds</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span> <span class="n">gc_gen_config</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Let&rsquo;s talk about why we need 4 colors for describing the state of the object in relevance to current garbage collection cycle.
In traditional tri-color garbage collector objects can be <em>white</em>, <em>grey</em> and <em>black</em>. Newly created objects are marked as <em>white</em>.
After object is identified to have a root reference it&rsquo;s color is changed from <em>white</em> to <em>grey</em>. Next all <em>grey</em> objects are checked for
references of other objects that they contain. For each contained reference if reference is <em>white</em> it&rsquo;s marked as <em>grey</em> for future checking after which the container object is marked as <em>black</em>. All remaining <em>grey</em> objects are subsequently checked for references of objects they contain. After this checks we have only <em>black</em> and <em>white</em> objects. Objects marked as <em>black</em> are reachable from the root and hence don&rsquo;t need to be garbage collected. Remaining white objects on the other hand are considered garbage and freed in the end. You can read about this in more detail <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking">here</a>.</p>

<p>Traditional tri-color algorithm doesn&rsquo;t has a notion of generation in mind because checking objects only in some specific limited generation won&rsquo;t be correct for determining if objects are garbage or not as some of those objects might have references from other generations. Let&rsquo;s consider that you have a generation of objects and you suddenly want to recheck them all. What you will probably do is mark all objects as <em>white</em> again and then mark objects that have root references as <em>grey</em> and go from there. However the problem with this approach is that in the end we might have white objects that don&rsquo;t have direct references in generation they are part of but have indirect reference from root objects in another generation. This is why we need 4 colors. We will treat those objects as <em>silver</em> and won&rsquo;t consider them as <em>white</em> yet. For each such object we&rsquo;ll check all <em>black</em> objects in all generations for possible references. If such reference will be found we&rsquo;ll mark that object as <em>grey</em> and will promote it to the generation that has reference to it. This might introduce some generation bouncing but since all live objects in all generations are subsequently promoted after some period of time to last generation this won&rsquo;t be a problem.</p>

<p>Since we need to be incremental during our garbage collection cycle for all white objects that are considered garbage we&rsquo;ll have a separate color that we&rsquo;ll call <em>transparent</em>, but we won&rsquo;t need additional bit in <strong>gc_mark</strong> to identify objects with such color. This kind objects won&rsquo;t be marked directly but instead will be part of <strong>transparent</strong> list that will be used during last step in our incremental garbage collection cycle to call <strong>gc_finalize</strong> function for each object in that list and <strong>free</strong> it from memory. This is needed because <strong>gc_finalize</strong> and <strong>free</strong> calls can be time costly operations hence we need to delay them until our gc cycle is fully over so they could be executed in the remaining cycle time. This way we can have a nearly timely precise incremental garbage collector that won&rsquo;t ever exceed our predefined <strong>max_pause</strong> time.</p>

<p>Since we are going to count time using nanoseconds we need a way to measure nanoseconds passed between execution of arbitrary code.
For this we&rsquo;ll use Linux <em>syscall</em> <strong>clock_gettime</strong>.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// get current time in nano seconds</span>
</span><span class='line'><span class="kt">uint64_t</span> <span class="nf">get_nanotime</span><span class="p">(){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">struct</span> <span class="n">timespec</span> <span class="n">t</span><span class="p">;</span>
</span><span class='line'><span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">t</span><span class="p">);</span>
</span><span class='line'><span class="k">return</span> <span class="p">(((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">t</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span><span class="o">*</span><span class="mi">1000000000</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">t</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Now let&rsquo;s define some global constants and variables for our garbage collector. Note how we are going to have
single double linked lists for each gc color except <em>black</em>.
Each generation will have it&rsquo;s own <em>black</em> objects list and hence we&rsquo;ll need an array of doubly linked objects lists.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">WHITE</span> <span class="mi">0</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">GREY</span>  <span class="mi">1</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">BLACK</span> <span class="mi">2</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">SILVER</span> <span class="mi">3</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// gc configuration</span>
</span><span class='line'><span class="k">static</span> <span class="n">gc_config</span> <span class="n">conf</span><span class="p">;</span>
</span><span class='line'><span class="c1">// gc list variables</span>
</span><span class='line'><span class="k">static</span> <span class="n">gc_object</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">transparent</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>
</span><span class='line'><span class="k">static</span> <span class="n">gc_object</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">white</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>
</span><span class='line'><span class="k">static</span> <span class="n">gc_object</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">silver</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>
</span><span class='line'><span class="k">static</span> <span class="n">gc_object</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">grey</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>
</span><span class='line'><span class="k">static</span> <span class="n">gc_object</span><span class="o">**</span> <span class="n">black</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Finally we can start writing some functions. Let&rsquo;s start with Garbage Collector initialization function first.
This will be called on startup and only once. It checks if generation count is correct and next thing is it just copies over configuration object including
the contained generation configurations.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// initialize garbage collector</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">gc_init</span><span class="p">(</span><span class="n">gc_config</span><span class="o">*</span> <span class="n">config</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// number of generations can&#39;t be more than 64 or equal to 0</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">config</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gens_count</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">config</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gens_count</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="mi">64</span><span class="p">){</span>
</span><span class='line'>    <span class="n">errno</span> <span class="o">=</span> <span class="n">EINVAL</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// copy config</span>
</span><span class='line'><span class="n">conf</span> <span class="o">=</span> <span class="o">*</span><span class="n">config</span><span class="p">;</span>
</span><span class='line'><span class="n">conf</span><span class="p">.</span><span class="n">gens</span> <span class="o">=</span> <span class="p">(</span><span class="n">gc_gen_config</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">gc_gen_config</span><span class="p">)</span> <span class="o">*</span> <span class="n">conf</span><span class="p">.</span><span class="n">gens_count</span><span class="p">);</span>
</span><span class='line'><span class="n">black</span> <span class="o">=</span> <span class="p">(</span><span class="n">gc_object</span><span class="o">**</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">gc_object</span><span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">conf</span><span class="p">.</span><span class="n">gens_count</span><span class="p">);</span>
</span><span class='line'><span class="c1">// foreach generation config</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">conf</span><span class="p">.</span><span class="n">gens_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
</span><span class='line'>    <span class="c1">// copy config and initialize generation</span>
</span><span class='line'>    <span class="n">conf</span><span class="p">.</span><span class="n">gens</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">config</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gens</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>    <span class="n">conf</span><span class="p">.</span><span class="n">gens</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">refresh_time</span> <span class="o">=</span> <span class="n">get_nanotime</span><span class="p">();</span>
</span><span class='line'>    <span class="n">conf</span><span class="p">.</span><span class="n">gens</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">promotion_time</span> <span class="o">=</span> <span class="n">conf</span><span class="p">.</span><span class="n">gens</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">refresh_time</span><span class="p">;</span>
</span><span class='line'>    <span class="n">black</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>We also need a function to destroy our garbage collector when it&rsquo;s not needed anymore.
This needs to free up all doubly linked lists as those can be considered part of garbage collector.
Note how we call <strong>gc_finalize</strong> function before freeing up object.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// completely free entire list finalizing all objects inside</span>
</span><span class='line'><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">gc_free_list</span><span class="p">(</span><span class="n">gc_object</span><span class="o">*</span> <span class="n">list</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">while</span><span class="p">(</span><span class="n">list</span> <span class="o">!=</span> <span class="n">null</span><span class="p">){</span>
</span><span class='line'>    <span class="n">gc_object</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span>
</span><span class='line'>    <span class="n">list</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_next</span><span class="p">;</span>
</span><span class='line'>    <span class="p">(</span><span class="n">obj</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">class</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_finalize</span><span class="p">)(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'>    <span class="n">free</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// deinitialize garbage collector</span>
</span><span class='line'><span class="kt">void</span> <span class="n">gc_destroy</span><span class="p">(){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// free all objects from all lists</span>
</span><span class='line'><span class="n">gc_free_list</span><span class="p">(</span><span class="n">transparent</span><span class="p">);</span>
</span><span class='line'><span class="n">gc_free_list</span><span class="p">(</span><span class="n">white</span><span class="p">);</span>
</span><span class='line'><span class="n">gc_free_list</span><span class="p">(</span><span class="n">silver</span><span class="p">);</span>
</span><span class='line'><span class="n">gc_free_list</span><span class="p">(</span><span class="n">grey</span><span class="p">);</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">conf</span><span class="p">.</span><span class="n">gens_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>    <span class="n">gc_free_list</span><span class="p">(</span><span class="n">black</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class='line'><span class="c1">// remove black list and generation configs</span>
</span><span class='line'><span class="n">free</span><span class="p">(</span><span class="n">black</span><span class="p">);</span>
</span><span class='line'><span class="n">free</span><span class="p">(</span><span class="n">conf</span><span class="p">.</span><span class="n">gens</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Now let&rsquo;s define some helper functions for working with doubly linked lists.
We&rsquo;ll use those to add, remove, and move objects from one list to another.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// add object to list</span>
</span><span class='line'><span class="kr">inline</span> <span class="kt">void</span> <span class="nf">gc_list_add</span><span class="p">(</span><span class="n">gc_object</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;*</span> <span class="n">list</span><span class="p">,</span> <span class="n">gc_object</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">obj</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">obj</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_next</span> <span class="o">=</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">obj</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_next</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span>
</span><span class='line'>    <span class="n">obj</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_next</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;(</span><span class="n">obj</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_next</span><span class="p">);</span>
</span><span class='line'><span class="n">obj</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_prev</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span>
</span><span class='line'><span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// remove object from current list</span>
</span><span class='line'><span class="kr">inline</span> <span class="kt">void</span> <span class="n">gc_list_remove</span><span class="p">(</span><span class="n">gc_object</span><span class="o">*</span> <span class="n">obj</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;*</span><span class="p">(</span><span class="n">obj</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_prev</span><span class="p">)</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_next</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">obj</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_next</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span>
</span><span class='line'>    <span class="n">obj</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_next</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_prev</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_prev</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// move object to list</span>
</span><span class='line'><span class="kr">inline</span> <span class="kt">void</span> <span class="n">gc_list_move</span><span class="p">(</span><span class="n">gc_object</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="n">gc_object</span><span class="o">**</span> <span class="n">list</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">gc_list_remove</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="n">gc_list_add</span><span class="p">(</span><span class="n">list</span><span class="p">,</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// move all objects from list to list</span>
</span><span class='line'><span class="kr">inline</span> <span class="kt">void</span> <span class="n">gc_list_move_all</span><span class="p">(</span><span class="n">gc_object</span><span class="o">&lt;</span><span class="n">strong</span><span class="o">&gt;</span> <span class="n">from</span><span class="p">,</span> <span class="n">gc_object</span><span class="o">&lt;/</span><span class="n">strong</span><span class="o">&gt;</span> <span class="n">to</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">to</span> <span class="o">!=</span> <span class="n">null</span><span class="p">){</span>
</span><span class='line'>    <span class="n">gc_object</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="o">*</span><span class="n">from</span><span class="p">;</span>
</span><span class='line'>    <span class="k">while</span><span class="p">(</span><span class="n">obj</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_next</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span>
</span><span class='line'>        <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_next</span><span class="p">;</span>
</span><span class='line'>    <span class="n">obj</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_next</span> <span class="o">=</span> <span class="o">*</span><span class="n">to</span><span class="p">;</span>
</span><span class='line'>    <span class="p">(</span><span class="o">*</span><span class="n">to</span><span class="p">)</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;(</span><span class="n">obj</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_next</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="o">*</span><span class="n">from</span><span class="p">;</span>
</span><span class='line'><span class="p">(</span><span class="o">*</span><span class="n">to</span><span class="p">)</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_prev</span> <span class="o">=</span> <span class="n">to</span><span class="p">;</span>
</span><span class='line'><span class="o">*</span><span class="n">from</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Now in order to determine if object is reachable or not we&rsquo;ll just use root reference counting instead of going over the stack and marking objects each time.
This might be considered more expensive as each time we set a reference to some object on the stack we need to increment it&rsquo;s root reference count.
And every time we pop a stack frame or modify a reference on the stack we need to decrement root reference count. Doing this many times is expensive indeed however from my point of view this approach is more faster in long term compared to scanning the stack each time during garbage collection. But if you really want it our simple garbage collector can be easily modified to use the scanning approach if needed.</p>

<p>As you can see from code when we increment root reference count we also check if object is white and mark it as grey for future check by Garbage Collector.
We could omit this step, however in doing so we would require to go through entire white objects set and check their root reference count each time during Garbage Collector cycle. As you can see there are no additional steps during decrement of root reference count, and that is because we don&rsquo;t need to do anything since when root reference count becomes 0 our object will still be refreshed during generation refresh phase and during it the root reference count will be checked anyway.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// add gc root</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">gc_add_root</span><span class="p">(</span><span class="n">gc_object</span><span class="o">*</span> <span class="n">obj</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// increase root ref count</span>
</span><span class='line'><span class="n">gc_inc_root_ref_count</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="c1">// mark object as grey if it&#39;s white or silver</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">gc_color_is_silver_or_white</span><span class="p">(</span><span class="n">obj</span><span class="p">)){</span>
</span><span class='line'>    <span class="n">gc_list_move</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">grey</span><span class="p">);</span>
</span><span class='line'>    <span class="n">gc_mark_grey</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// remove gc root</span>
</span><span class='line'><span class="kt">void</span> <span class="n">gc_remove_root</span><span class="p">(</span><span class="n">gc_object</span><span class="o">*</span> <span class="n">obj</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// decrease root ref count</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">gc_root_ref_count</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="n">gc_dec_root_ref_count</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Next thing we need to do is to actually allocate the object itself and initialize it&rsquo;s <strong>gc_mark</strong>.
We also need to add it to white objects list as all new objects should be added to white list.
Without it we won&rsquo;t be able to track allocated objects. Look at how we also initialize references to <em>null</em>
based on how much references an object could contain. This is specified using <strong>refs_count</strong> argument to the function.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// allocate gc_object</span>
</span><span class='line'><span class="n">gc_object</span><span class="o">*</span> <span class="nf">gc_alloc</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">refs_count</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// allocate new white object in generation 0 with 0 root ref count</span>
</span><span class='line'><span class="n">gc_object</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">(</span><span class="n">gc_object</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">gc_object</span><span class="p">)</span> <span class="o">+</span> <span class="n">refs_count</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">gc_object</span><span class="o">*</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// initialize references</span>
</span><span class='line'><span class="n">obj</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">refs_count</span> <span class="o">=</span> <span class="n">refs_count</span><span class="p">;</span> <span class="c1">// number of references this object might contain</span>
</span><span class='line'><span class="n">gc_object</span><span class="o">**</span> <span class="n">refs</span> <span class="o">=</span> <span class="p">(</span><span class="n">gc_object</span><span class="o">**</span><span class="p">)(</span><span class="n">obj</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// start of refs array</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">refs_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>    <span class="n">refs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// set gc mark</span>
</span><span class='line'><span class="n">obj</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_mark</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// initial gc_mark value (0 generation white color)</span>
</span><span class='line'><span class="c1">// add object to white list</span>
</span><span class='line'><span class="n">gc_list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">white</span><span class="p">,</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Since our object could contain references we need a way to be able to modify those references.
Since we are introducing mutation we need to be able to revert the color of black object back to grey in order
to be able to recheck it during gc cycle. This operation is not expensive and is executed only once during mutation
between gc cycles if mutation of the object occurs thus we don&rsquo;t get any performance penalties by doing so each time on
reference modification.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// set object reference to another object</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">gc_set_ref</span><span class="p">(</span><span class="n">gc_object</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">obj</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">ref_index</span><span class="p">,</span> <span class="n">gc_object</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">ref</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">gc_object</span><span class="o">**</span> <span class="n">refs</span> <span class="o">=</span> <span class="p">(</span><span class="n">gc_object</span><span class="o">**</span><span class="p">)(</span><span class="n">obj</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// start of refs array</span>
</span><span class='line'><span class="n">refs</span><span class="p">[</span><span class="n">ref_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">ref</span><span class="p">;</span>
</span><span class='line'><span class="c1">// if object is black because it mutated we need to mark it grey again</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">gc_color_is_black</span><span class="p">(</span><span class="n">obj</span><span class="p">)){</span>
</span><span class='line'>    <span class="n">gc_list_move</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">grey</span><span class="p">);</span>
</span><span class='line'>    <span class="n">gc_mark_grey</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Let&rsquo;s start writing <strong>gc</strong> function. First we need to initialize cycle counters which we&rsquo;ll be used during our gc cycle. I&rsquo;ve added
this variables to <strong>gc_config</strong> <em>struct</em> just for the sake of simplicity.
First thing we are going to do during our gc cycle is to free all transparent objects that might have been left over from the previous gc cycle. Before freeing each object we call <strong>gc_finalize</strong> function from it&rsquo;s <em>class</em>. Note however that since we are writing an incremental garbage collector we need to be able to end the cycle prematurely if it takes too much time. To do so we&rsquo;ll be using <strong>gc_cycle_check</strong> <em>macro</em>. In order for <em>gc_cycle_check</em> to determine if the check for threshold should occur or not we increment <strong>cycle_threshold</strong> counter.
During <strong>gc_cycle_check</strong> we just check if <strong>cycle_threshold</strong> is bigger than configured <strong>pause_threshold</strong> and if it is we just check the amount of passed time in nano seconds since the start of the gc cycle. If the time passed exceeds <strong>max_pause</strong> configuration value we just call <strong>gc_cycle_end</strong> function and end cycle prematurely.
We&rsquo;ll rely on <strong>gc_cycle_check</strong> <em>macro</em> heavily through our entire gc cycle.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">gc_cycle_check</span> <span class="err">\</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">if</span><span class="p">(</span><span class="n">conf</span><span class="p">.</span><span class="n">cycle_threshold</span> <span class="o">&gt;=</span> <span class="n">conf</span><span class="p">.</span><span class="n">pause_threshold</span><span class="p">){</span> <span class="err">\</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span><span class="p">((</span><span class="n">get_nanotime</span><span class="p">()</span> <span class="o">-</span> <span class="n">conf</span><span class="p">.</span><span class="n">cycle_time</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="n">conf</span><span class="p">.</span><span class="n">max_pause</span><span class="p">){</span> \
</span><span class='line'>    <span class="k">return</span> <span class="n">gc_cycle_end</span><span class="p">();</span> \
</span><span class='line'><span class="p">}</span> \
</span><span class='line'><span class="n">conf</span><span class="p">.</span><span class="n">cycle_objects</span> <span class="o">+=</span> <span class="n">conf</span><span class="p">.</span><span class="n">cycle_threshold</span><span class="p">;</span> \
</span><span class='line'><span class="n">conf</span><span class="p">.</span><span class="n">cycle_threshold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> \
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// end gc cycle</span>
</span><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint64_t</span> <span class="n">gc_cycle_end</span><span class="p">(){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">conf</span><span class="p">.</span><span class="n">cycle_objects</span> <span class="o">+=</span> <span class="n">conf</span><span class="p">.</span><span class="n">cycle_threshold</span><span class="p">;</span>
</span><span class='line'><span class="n">conf</span><span class="p">.</span><span class="n">cycle_duration</span> <span class="o">=</span> <span class="n">get_nanotime</span><span class="p">()</span> <span class="o">-</span> <span class="n">conf</span><span class="p">.</span><span class="n">cycle_time</span><span class="p">;</span>
</span><span class='line'><span class="k">return</span> <span class="n">conf</span><span class="p">.</span><span class="n">cycle_duration</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// start gc cycle</span>
</span><span class='line'><span class="n">conf</span><span class="p">.</span><span class="n">cycle_time</span> <span class="o">=</span> <span class="n">get_nanotime</span><span class="p">();</span>
</span><span class='line'><span class="n">conf</span><span class="p">.</span><span class="n">cycle_threshold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">conf</span><span class="p">.</span><span class="n">cycle_objects</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">conf</span><span class="p">.</span><span class="n">cycle_collected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">conf</span><span class="p">.</span><span class="n">cycle_full</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// transparent cleanup phase before cycle</span>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="n">transparent</span> <span class="o">!=</span> <span class="n">null</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="p">(</span><span class="n">transparent</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">class</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_finalize</span><span class="p">)(</span><span class="n">transparent</span><span class="p">);</span>
</span><span class='line'><span class="n">gc_object</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">transparent</span><span class="p">;</span>
</span><span class='line'><span class="n">transparent</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_next</span><span class="p">;</span>
</span><span class='line'><span class="n">free</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="n">conf</span><span class="p">.</span><span class="n">cycle_threshold</span> <span class="o">+=</span> <span class="mi">11</span><span class="p">;</span>
</span><span class='line'><span class="n">conf</span><span class="p">.</span><span class="n">cycle_collected</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="c1">// check pause threshold</span>
</span><span class='line'><span class="n">gc_cycle_check</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>After cleaning up transparent list next thing what we are going to do is promote generations that need promotion and refresh those that need refreshment.
Now this might sound something complex but it&rsquo;s pretty much straight forward. We just track time of last promotion and refreshment for each generation in <strong>promotion_time</strong> and
<strong>refresh_time</strong> variables and compare them with configuration intervals called <strong>promotiona_interval</strong> and <strong>refresh_interval</strong> configured individually for each generation.
Note how we skip promotion of the last generation as there is no generation to promote to. During promotion what we are doing is just incrementing generation setting and moving
object from one generation black list to another. Note that while doing that we also check gc pause threshold using <strong>gc_cylce_check</strong> <em>macro</em>. During refresh we are checking root
reference count and based on that move objects either to <em>grey</em> list or <em>silver</em>.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// promotion phase</span>
</span><span class='line'><span class="kt">uint64_t</span> <span class="n">time_now</span> <span class="o">=</span> <span class="n">get_nanotime</span><span class="p">();</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">conf</span><span class="p">.</span><span class="n">gens_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">conf</span><span class="p">.</span><span class="n">gens</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cycle_refreshed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">conf</span><span class="p">.</span><span class="n">gens</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cycle_promoted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">gc_object</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">black</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">obj</span> <span class="o">!=</span> <span class="n">null</span><span class="p">){</span>
</span><span class='line'>    <span class="c1">// promote generation</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="p">(</span><span class="n">conf</span><span class="p">.</span><span class="n">gens_count</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">time_now</span> <span class="o">-</span> <span class="n">conf</span><span class="p">.</span><span class="n">gens</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">promotion_time</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">conf</span><span class="p">.</span><span class="n">gens</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">promotion_interval</span><span class="p">){</span>
</span><span class='line'>        <span class="k">do</span><span class="p">{</span>
</span><span class='line'>            <span class="n">gc_gen_set</span><span class="p">(</span><span class="n">obj</span><span class="p">,(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
</span><span class='line'>            <span class="c1">// move to next generation</span>
</span><span class='line'>            <span class="n">gc_list_move</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;(</span><span class="n">black</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]));</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">conf</span><span class="p">.</span><span class="n">cycle_threshold</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>            <span class="n">conf</span><span class="p">.</span><span class="n">gens</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cycle_promoted</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>            <span class="c1">// check pause threshold</span>
</span><span class='line'>            <span class="n">gc_cycle_check</span>
</span><span class='line'>            <span class="n">obj</span> <span class="o">=</span> <span class="n">black</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="n">obj</span> <span class="o">!=</span> <span class="n">null</span><span class="p">);</span>
</span><span class='line'>        <span class="n">conf</span><span class="p">.</span><span class="n">gens</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">promotion_time</span> <span class="o">=</span> <span class="n">get_nanotime</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// refresh generation</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">time_now</span> <span class="o">-</span> <span class="n">conf</span><span class="p">.</span><span class="n">gens</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">refresh_time</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">conf</span><span class="p">.</span><span class="n">gens</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">refresh_interval</span><span class="p">){</span>
</span><span class='line'>        <span class="k">while</span><span class="p">(</span><span class="n">obj</span> <span class="o">!=</span> <span class="n">null</span><span class="p">){</span>
</span><span class='line'>            <span class="c1">// if has root references</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="n">gc_root_ref_count</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>                <span class="c1">// mark as grey</span>
</span><span class='line'>                <span class="n">gc_list_move</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">grey</span><span class="p">);</span>
</span><span class='line'>                <span class="n">gc_mark_grey</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'>                <span class="c1">// mark as silver</span>
</span><span class='line'>                <span class="n">gc_list_move</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">silver</span><span class="p">);</span>
</span><span class='line'>                <span class="n">gc_mark_silver</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="n">conf</span><span class="p">.</span><span class="n">cycle_threshold</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>            <span class="n">conf</span><span class="p">.</span><span class="n">gens</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cycle_refreshed</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>            <span class="c1">// check pause threshold</span>
</span><span class='line'>            <span class="n">gc_cycle_check</span>
</span><span class='line'>            <span class="n">obj</span> <span class="o">=</span> <span class="n">black</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">conf</span><span class="p">.</span><span class="n">gens</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">refresh_time</span> <span class="o">=</span> <span class="n">get_nanotime</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Next phase after promotion/refreshment is marking phase.
During this phase we go over all <em>grey</em> objects and mark them as <em>black</em> using class assigned <strong>gc_mark_black</strong> function pointer.
Now in our <em>gc_object</em>&rsquo;s class we assigned it to <strong>gc_object_mark_black</strong> function which is straightforward as we just iterate over
references object contains, mark them as <em>grey</em> if they are <em>white</em> or <em>silver</em> and after that mark object as <em>black</em>.
Note how we are using <strong>gc_cycle_check_no_return</strong> <em>macro</em> which is almost the same as <strong>gc_cycle_check</strong> <em>macro</em> except that it doesn&rsquo;t
 ends the cycle by calling <strong>gc_cycle_end</strong> as we are doing the same check in caller code using <strong>gc_cycle_check</strong> <em>macro</em>.
This is needed to end cycle prematurely from callee <em>gc_mark_black</em> function.
This might sound as overly complex but this way we can extend our garbage collector to support objects with any kind of reference layout which might come handy for future.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// mark phase</span>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="n">grey</span> <span class="o">!=</span> <span class="n">null</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="p">(</span><span class="n">grey</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">class</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_mark_black</span><span class="p">)(</span><span class="n">grey</span><span class="p">);</span>
</span><span class='line'><span class="n">conf</span><span class="p">.</span><span class="n">cycle_threshold</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="c1">// check pause threshold</span>
</span><span class='line'><span class="n">gc_cycle_check</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">gc_cycle_check_no_return</span> <span class="err">\</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">if</span><span class="p">(</span><span class="n">conf</span><span class="p">.</span><span class="n">cycle_threshold</span> <span class="o">&gt;=</span> <span class="n">conf</span><span class="p">.</span><span class="n">pause_threshold</span><span class="p">){</span> <span class="err">\</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span><span class="p">((</span><span class="n">get_nanotime</span><span class="p">()</span> <span class="o">-</span> <span class="n">conf</span><span class="p">.</span><span class="n">cycle_time</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="n">conf</span><span class="p">.</span><span class="n">max_pause</span><span class="p">){</span> \
</span><span class='line'>    <span class="k">return</span><span class="p">;</span> \
</span><span class='line'><span class="p">}</span> \
</span><span class='line'><span class="n">conf</span><span class="p">.</span><span class="n">cycle_objects</span> <span class="o">+=</span> <span class="n">conf</span><span class="p">.</span><span class="n">cycle_threshold</span><span class="p">;</span> \
</span><span class='line'><span class="n">conf</span><span class="p">.</span><span class="n">cycle_threshold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> \
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// gc object mark black</span>
</span><span class='line'><span class="kt">void</span> <span class="n">gc_object_mark_black</span><span class="p">(</span><span class="n">gc_object</span><span class="o">*</span> <span class="n">obj</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">gc_object</span><span class="o">**</span> <span class="n">refs</span> <span class="o">=</span> <span class="p">(</span><span class="n">gc_object</span><span class="o">**</span><span class="p">)(</span><span class="n">obj</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// start of refs array</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// for each ref</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">obj</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">refs_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">refs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">null</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">gc_color_is_silver_or_white</span><span class="p">(</span><span class="n">refs</span><span class="p">[</span><span class="n">i</span><span class="p">])){</span>
</span><span class='line'>        <span class="c1">// mark object as grey</span>
</span><span class='line'>        <span class="n">gc_list_move</span><span class="p">(</span><span class="n">refs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">grey</span><span class="p">);</span>
</span><span class='line'>        <span class="n">gc_mark_grey</span><span class="p">(</span><span class="n">refs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span class='line'>        <span class="n">conf</span><span class="p">.</span><span class="n">cycle_threshold</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="c1">// check pause threshold</span>
</span><span class='line'>        <span class="n">gc_cycle_check_no_return</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// mark object as black</span>
</span><span class='line'><span class="n">gc_list_move</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;(</span><span class="n">black</span><span class="p">[</span><span class="n">gc_gen_num</span><span class="p">(</span><span class="n">obj</span><span class="p">)]));</span>
</span><span class='line'><span class="n">gc_mark_black</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Next comes the tricky part. Now we are left with <em>silver</em> objects that aren&rsquo;t entirely white or grey yet.
What we are going to do is to go through all generations starting with older ones and check if objects in that generation might contain
our <em>silver</em> object. This might sound trivial but it&rsquo;s more tricky. We are going to check our <em>silver</em> objects using <strong>gc_contains</strong> function pointer in the <em>class</em>
which in our case will point to <strong>gc_object_contains</strong> function. This is all for the same sake of extensibility of our garbage collector.
Now if the object is not found in all black objects of all generations we can safely mark it as <em>white</em>. On the other hand if it&rsquo;s found  we need to
first correct it&rsquo;s generation, mark it as <em>grey</em> and recheck all left over <em>grey</em> objects all over again in order to safely trace references that this object might contain which on the other hand might be some <em>silver</em> objects too. This way we decrease the amount of <em>silver</em> objects that we need to check to essential minimum as the operation itself is very expensive.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// mark silver phase</span>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="n">silver</span> <span class="o">!=</span> <span class="n">null</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'><span class="kt">uint8_t</span> <span class="n">to_gen</span><span class="p">;</span>
</span><span class='line'><span class="kt">uint8_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">conf</span><span class="p">.</span><span class="n">gens_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
</span><span class='line'>    <span class="n">gc_object</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">black</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>    <span class="k">while</span><span class="p">(</span><span class="n">obj</span> <span class="o">!=</span> <span class="n">null</span><span class="p">){</span>
</span><span class='line'>        <span class="k">if</span><span class="p">((</span><span class="n">obj</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">class</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_contains</span><span class="p">)(</span><span class="n">obj</span><span class="p">,</span><span class="n">silver</span><span class="p">)){</span>
</span><span class='line'>            <span class="n">found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>            <span class="n">to_gen</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>            <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">gc_cycle_check</span>
</span><span class='line'>        <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_next</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">found</span> <span class="o">||</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="o">--</span><span class="n">i</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">found</span><span class="p">){</span>
</span><span class='line'>    <span class="c1">// correct generation and mark as grey</span>
</span><span class='line'>    <span class="n">gc_gen_set</span><span class="p">(</span><span class="n">silver</span><span class="p">,</span><span class="n">to_gen</span><span class="p">);</span>
</span><span class='line'>    <span class="n">gc_mark_grey</span><span class="p">(</span><span class="n">silver</span><span class="p">);</span>
</span><span class='line'>    <span class="n">gc_list_move</span><span class="p">(</span><span class="n">silver</span><span class="p">,</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">grey</span><span class="p">);</span>
</span><span class='line'>    <span class="n">conf</span><span class="p">.</span><span class="n">cycle_threshold</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">// run mark grey phase</span>
</span><span class='line'>    <span class="k">while</span><span class="p">(</span><span class="n">grey</span> <span class="o">!=</span> <span class="n">null</span><span class="p">){</span>
</span><span class='line'>        <span class="p">(</span><span class="n">grey</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">class</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_mark_black</span><span class="p">)(</span><span class="n">grey</span><span class="p">);</span>
</span><span class='line'>        <span class="n">conf</span><span class="p">.</span><span class="n">cycle_threshold</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="c1">// check pause threshold</span>
</span><span class='line'>        <span class="n">gc_cycle_check</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'>    <span class="c1">// mark as white</span>
</span><span class='line'>    <span class="n">gc_mark_white</span><span class="p">(</span><span class="n">silver</span><span class="p">);</span>
</span><span class='line'>    <span class="n">gc_list_move</span><span class="p">(</span><span class="n">silver</span><span class="p">,</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">white</span><span class="p">);</span>
</span><span class='line'>    <span class="n">conf</span><span class="p">.</span><span class="n">cycle_threshold</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// check pause threshold</span>
</span><span class='line'><span class="n">gc_cycle_check</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// this checks if object contains reference object</span>
</span><span class='line'><span class="n">bool</span> <span class="n">gc_object_contains</span><span class="p">(</span><span class="n">gc_object</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">obj</span><span class="p">,</span> <span class="n">gc_object</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">ref</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">conf</span><span class="p">.</span><span class="n">cycle_threshold</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="n">gc_object</span><span class="o">**</span> <span class="n">refs</span> <span class="o">=</span> <span class="p">(</span><span class="n">gc_object</span><span class="o">**</span><span class="p">)(</span><span class="n">obj</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// start of refs array</span>
</span><span class='line'><span class="k">for</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">obj</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">refs_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">refs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">ref</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Finally we need to sweep all <em>white</em> objects, by moving them to <em>transparent</em> list.
Next we just cleanup the <em>transparent</em> list again while also checking for the pause threshold using <strong>gc_cycle_check</strong> <em>macro</em> again.
And finally we mark cycle as full and end it using <strong>gc_cycle_end</strong> function.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// sweep phase</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">white</span> <span class="o">!=</span> <span class="n">null</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// make object transparent</span>
</span><span class='line'><span class="n">gc_list_move_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">white</span><span class="p">,</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">transparent</span><span class="p">);</span>
</span><span class='line'><span class="n">conf</span><span class="p">.</span><span class="n">cycle_threshold</span> <span class="o">+=</span> <span class="mi">50</span><span class="p">;</span>
</span><span class='line'><span class="c1">// check pause threshold</span>
</span><span class='line'><span class="n">gc_cycle_check</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// transparent cleanup phase after cycle</span>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="n">transparent</span> <span class="o">!=</span> <span class="n">null</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="p">(</span><span class="n">transparent</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">class</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_finalize</span><span class="p">)(</span><span class="n">transparent</span><span class="p">);</span>
</span><span class='line'><span class="n">gc_object</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">transparent</span><span class="p">;</span>
</span><span class='line'><span class="n">transparent</span> <span class="o">=</span> <span class="n">obj</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">gc_next</span><span class="p">;</span>
</span><span class='line'><span class="n">free</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="n">conf</span><span class="p">.</span><span class="n">cycle_threshold</span> <span class="o">+=</span> <span class="mi">11</span><span class="p">;</span>
</span><span class='line'><span class="n">conf</span><span class="p">.</span><span class="n">cycle_collected</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="c1">// check pause threshold</span>
</span><span class='line'><span class="n">gc_cycle_check</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// set cycle full</span>
</span><span class='line'><span class="n">conf</span><span class="p">.</span><span class="n">cycle_full</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">return</span> <span class="n">gc_cycle_end</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Now that we have a garbage collector we need a way to test it to be sure it&rsquo;s working correctly.
To do that we&rsquo;ll create a micro DSL test language that will look like this. This language is inspired by a similar
language that I&rsquo;ve created to test memory allocator in previous article. This language is fairly compact.
Note that putting an object into the slot doesn&rsquo;t means it automatically has a root reference. Objects that don&rsquo;t have root reference or
are referenced by root objects might get deleted after gc but our test compiler will check that kind of objects during compilation so we won&rsquo;t have any <em>Segmentation Fault</em>.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1>one line comment starts with # character&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;p>0=12   # allocate an object that can contain 12 references and set it to slot 0
</span><span class='line'>+0     # increment root reference count of the object that is in slot 0
</span><span class='line'>-0     # decrement root reference count of the object that is in slot 0
</span><span class='line'>0[0]=1 # set first reference of object in slot 0 to be object in slot 1
</span><span class='line'>gc     # call garbage collector
</span><span class='line'>0=2 gc # multiple statements are separated by white space or new line</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>In order to actually write tests for that I&rsquo;ve created <em>gctestgen.rb</em> <em>Ruby</em> script that can generate random test files of any size.
This test have iterations. In each iteration first we allocate objects, then we decrement root reference counts of some random objects from previous iteration.
After that we initialize references in objects randomly and run garbage collection. This way we simulate behaviour of an application allocating objects and running garbage collection.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;-n number of iterations&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;-c objects per iteration&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;-f maximum number of references object can have&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;-r percentage of root objects&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;-s percentage of survivors&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;-d percentage of root objects to decrement on next iteration&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;<span class="nv">$ </span>./gctestgen.rb -n 60 -c 1000 -f 32 -s 20 -r 10 -d 5 &gt; test.t
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Now in order to compile our test I wrote a mini meta-compiler <strong>gctest.rb</strong> in <em>Ruby</em> that generates <em>.c</em> file for testing and links it against our garbage collector and creates executable binary <strong>gctest</strong>.
While compiling it also simulates garbage collection (simple full garbage collection each time) and counts expected number of objects to survive entire test.
After that it runs that executable and compares it&rsquo;s output to expected count to proof correctness of the garbage collector. The source code is in repository so you could all study it.
The following initial configuration is provided for testing which is just 3 generations.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// initialize gc object class</span>
</span><span class='line'><span class="n">cls</span><span class="p">.</span><span class="n">gc_mark_black</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">gc_object_mark_black</span><span class="p">;</span>
</span><span class='line'><span class="n">cls</span><span class="p">.</span><span class="n">gc_contains</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">gc_object_contains</span><span class="p">;</span>
</span><span class='line'><span class="n">cls</span><span class="p">.</span><span class="n">gc_finalize</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">garbage_collected_finalize</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// initialize gc configuration</span>
</span><span class='line'><span class="n">gc_config</span> <span class="n">config</span><span class="p">;</span>
</span><span class='line'><span class="n">gc_gen_config</span> <span class="n">c</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span><span class='line'><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">refresh_interval</span> <span class="o">=</span> <span class="mi">500000ull</span><span class="p">;</span> <span class="c1">// 0.5 millis</span>
</span><span class='line'><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">promotion_interval</span> <span class="o">=</span> <span class="mi">1000000ull</span><span class="p">;</span> <span class="c1">// 1 millis</span>
</span><span class='line'><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">refresh_interval</span> <span class="o">=</span> <span class="mi">2000000ull</span><span class="p">;</span> <span class="c1">// 2 millis</span>
</span><span class='line'><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">promotion_interval</span> <span class="o">=</span> <span class="mi">6000000ull</span><span class="p">;</span> <span class="c1">// 6 millis</span>
</span><span class='line'><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">refresh_interval</span> <span class="o">=</span> <span class="mi">250000000ull</span><span class="p">;</span> <span class="c1">// 15 millis</span>
</span><span class='line'><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">promotion_interval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// not needed for last generation</span>
</span><span class='line'><span class="n">config</span><span class="p">.</span><span class="n">gens_count</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'><span class="n">config</span><span class="p">.</span><span class="n">gens</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
</span><span class='line'><span class="n">config</span><span class="p">.</span><span class="n">pause_threshold</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">// 100 objects</span>
</span><span class='line'><span class="n">config</span><span class="p">.</span><span class="n">max_pause</span> <span class="o">=</span> <span class="mi">200000000</span><span class="p">;</span> <span class="c1">// 200 milliseconds</span>
</span><span class='line'><span class="n">gc_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">config</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>./gctest.rb ./test.t
</span><span class='line'>total object allocations: 60000
</span><span class='line'>expected number of objects to survive gc: 4606
</span><span class='line'>running gc <span class="nb">test</span>: ./test.t
</span><span class='line'>gc collected 850 objects took 1.02 millis <span class="o">[</span> 0/0 0/0 0/0 <span class="o">]</span>
</span><span class='line'>gc collected 850 objects took 0.07 millis <span class="o">[</span> 142/0 142/0 0/0 <span class="o">]</span>
</span><span class='line'>gc collected 850 objects took 0.07 millis <span class="o">[</span> 148/0 0/0 0/0 <span class="o">]</span>
</span><span class='line'>&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip;..
</span><span class='line'>gc collected 856 objects took 2.93 millis <span class="o">[</span> 147/0 0/301 0/0 <span class="o">]</span>
</span><span class='line'>gc collected 850 objects took 0.09 millis <span class="o">[</span> 150/0 359/0 0/0 <span class="o">]</span>
</span><span class='line'><span class="nb">test </span>ended, took 246.68 millis
</span><span class='line'>gc collected 0 objects took 200.00 millis <span class="o">[</span> 153/0 155/0 0/8561 <span class="o">]</span>
</span><span class='line'>gc collected 0 objects took 200.00 millis <span class="o">[</span> 0/0 0/0 0/0 <span class="o">]</span>
</span><span class='line'>gc collected 0 objects took 200.00 millis <span class="o">[</span> 0/0 0/0 0/0 <span class="o">]</span>
</span><span class='line'>gc collected 3955 objects took 111.26 millis <span class="o">[</span> 0/0 0/0 0/0 <span class="o">]</span>
</span><span class='line'>checked objects that survived: 4606
</span><span class='line'>garbage collected 55394
</span><span class='line'>actual survivors 4606
</span><span class='line'>expected survivors match with actual survivors
</span><span class='line'>total gc calls: 60
</span><span class='line'>total <span class="nb">time </span>spent in gc: 53.74 millis
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>As you can see test took 250ms to allocate 60000 objects. Garbage collector was called 60 times and overall took 53.74ms after which only 4606 objects survived.
We wrote a <em>Garbage Collector</em>, finally. That&rsquo;s it folks, have a nice garbage collector hacking time!!!
<img src="http://i.imgur.com/OIcxN1t.png" alt="Space Dandy &amp; Loli" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lifting Shadows off a Memory Allocation]]></title>
    <link href="http://troydm.github.io/blog/2015/08/03/lifting-shadows-off-a-memory-allocation/"/>
    <updated>2015-08-03T18:32:35+04:00</updated>
    <id>http://troydm.github.io/blog/2015/08/03/lifting-shadows-off-a-memory-allocation</id>
    <content type="html"><![CDATA[<p>TL;DR <em>Writing power-of-2 malloc memory allocator in C</em></p>

<p>Any sufficiently advanced technology is indistinguishable from magic or so they say. Today we are going to lift some shadows from
the very basic thing that is dynamic memory management in an application process. This knowledge is essential for anyone who wants to write his/her own <em>Programming Language</em> so gaining this knowledge is not an optional thing since it opens a whole new lever of understanding how dynamic memory is managed by application and is split between different applications. To do that we need to have some basic understanding of how the actual physical thing is used by operating system. For those who don&rsquo;t know anything about <em>Virtual Memory</em> or what <em>Memory Pages</em> are and which algorithms modern operating systems are using to manage those I suggest reading <a href="http://www.amazon.com/Operating-System-Concepts-Abraham-Silberschatz/dp/1118063333/">Operating Systems Concepts</a> and for those who want to know all the guts of how <em>Linux</em> does this under the hood there is <a href="http://www.amazon.com/Understanding-Linux-Kernel-Third-Daniel/dp/0596005652/">Understanding Linux Kernel</a>.
<img src="http://i.imgur.com/VphDXNR.png" alt="Police Loli" /></p>

<!--more-->


<p>For the lazy rest to put it simply physical memory is split into fixed size blocks which are called <em>Memory Pages</em> and depending on the computer architecture and operating system can be 2kb 4kb 16kb 32kb or even 4mb in size. Anytime we request memory from operating system using some <em>syscall</em> it&rsquo;s best to have the size divisible by the actual operating operating system&rsquo;s <em>Memory Page</em> size. If used simply this tends to waste a lot of memory so hence we need a way to be more efficient with our requests and also we need to think of a way to recycle the memory requested before which isn&rsquo;t already needed by the application. All this opens a new area for exploration which is called Memory Allocation Algorithms and is quite a hot topic because not only we need to manage the recycling complexity but also concurrency and parallelism of the actual algorithms to be more efficient with modern multi-processor computers.
Some notable examples of algorithm that do that and are used in real world are <a href="http://g.oswego.edu/dl/html/malloc.html">Doug Lea&rsquo;s malloc</a>, <a href="http://tlsf.baisoku.org/">TLSF</a> and <a href="http://www.canonware.com/jemalloc/">jemalloc</a>, also there are much more out there. In order to explore some basic ideas about memory allocators we&rsquo;ll write the simplest algorithm commonly called power of 2. The essential idea behind it is to split blocks of memory into sizes divisible by 2 such as 32, 64, 128 and etc. By doing so we could reuse already used blocks by breaking them into more smaller onces. For example 128 block can be broken into 2 blocks of 64 and each of them can also further be broken to 32 sized blocks.</p>

<p><canvas id="memoryBlock" width="400" height="75"></canvas></p>

<script>
var c = document.getElementById("memoryBlock");
var ctx = c.getContext("2d");
ctx.font="normal 12pt Sans";
ctx.fillStyle = "#F8D7BB";
ctx.strokeStyle = "#000000";
ctx.fillRect(0,0,400,75);
ctx.moveTo(0,0);
ctx.lineTo(400,0);
ctx.stroke();
ctx.moveTo(0,0);
ctx.lineTo(0,75);
ctx.stroke();
ctx.moveTo(0,75);
ctx.lineTo(400,75);
ctx.stroke();
ctx.moveTo(400,0);
ctx.lineTo(400,75);
ctx.stroke();
ctx.moveTo(0,25);
ctx.lineTo(400,25);
ctx.stroke();
ctx.moveTo(200,25);
ctx.lineTo(200,75);
ctx.stroke();
ctx.moveTo(100,50);
ctx.lineTo(100,75);
ctx.stroke();
ctx.moveTo(0,50);
ctx.lineTo(200,50);
ctx.stroke();
ctx.moveTo(300,50);
ctx.lineTo(300,75);
ctx.stroke();
ctx.moveTo(200,50);
ctx.lineTo(400,50);
ctx.stroke();
ctx.moveTo(200,50);
ctx.lineTo(400,50);
ctx.stroke();
ctx.fillStyle = "#000000";
ctx.fillText("128",185,18);
ctx.fillText("64",92,43);
ctx.fillText("64",292,43);
ctx.fillText("32",46,67);
ctx.fillText("32",148,67);
ctx.fillText("32",246,67);
ctx.fillText("32",338,67);
</script>


<p>In general this tends to waste a lot of memory and introduces memory fragmentation. In worst case scenario half of all requested memory is wasted but usually in real world cases the actual number is near 25%. The memory wasting cost has computing performance gain as the algorithm itself is not hard to implement and works faster than more complex but conservative ones. Hence we are going to write a simple memory allocator also commonly called <em>malloc</em> since this is the library function name used by standard <em>C</em> library for allocating dynamic memory of variable size for the application process. We are going to implement our version of that function and related functions. Our target platform will be <em>Linux</em> and <em>gcc</em> compiler since we aren&rsquo;t going to bother with portability as this will take much more time and effort. Final version of source code can be browsed in <a href="https://github.com/troydm/mymalloc">mymalloc</a> repo but I strongly encourage you to write the whole thing from scratch yourself just to better understand the actual processes under the hood.</p>

<p>First let&rsquo;s start with function definitions that we need to reimplement. Create a file called <strong>mymalloc.h</strong>. We&rsquo;ll also define some functions for debug/stats purposes as those will be helpful during development process. Note: all this functions are defined by glibc in linux so gcc will complain about them being redefined during compilation but you can ignore those messages.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">calloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">nmemb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">s</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">realloc</span><span class="p">(</span><span class="kt">void</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ns</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">free</span><span class="p">(</span><span class="kt">void</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">);</span>
</span><span class='line'><span class="c1">// for debug use only</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">print_block_info</span><span class="p">(</span><span class="kt">void</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">print_freelist</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Now let&rsquo;s create a file called <strong>mymalloc.c</strong> and define the actual functions. We&rsquo;ll start with some initial values which are provided by operating system. The defined values are self explaining however I need to clarify the choice with 32 bytes for minimum block size. Since we&rsquo;ll manage memory blocks as doubly linked list nodes, each memory block needs to have space for at least two pointers and one size value which can&rsquo;t be more than the pointer size so that&rsquo;s 3 pointers for each node. Maximum size for 3 pointers for 64-bit operating system is 8 bytes so it&rsquo;s overall 24 bytes however block size needs to be power of 2 value and nearest size is 2<sup>5</sup> hence 32.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// for code clarity for pointers we use null instead of 0&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1>define null 0&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;p>// initial values&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1>define PAGE_SIZE (sysconf(_SC_PAGESIZE))&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>define MIN_BLOCK_SIZE 32 // bytes&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>We need a place to save free memory blocks and a way to manage them so let&rsquo;s first describe what memory block is and define initial doubly linked list for it that will contain <em>start</em> and <em>end</em> nodes pointing at each other. Those nodes won&rsquo;t be used and are there just so that our code won&rsquo;t contain conditional <em>if</em> statements when handling nodes.</p>

<p><canvas id="freelist" width="600" height="75"></canvas></p>

<script>
function drawRect(ctx,text,x,y,w,h){
    ctx.fillRect(x,y,w,h);
    ctx.moveTo(x,y);
    ctx.lineTo(x,y+h);
    ctx.stroke();
    ctx.moveTo(x,y);
    ctx.lineTo(x+w,y);
    ctx.stroke();
    ctx.moveTo(x+w,y);
    ctx.lineTo(x+w,y+h);
    ctx.stroke();
    ctx.moveTo(x,y+h);
    ctx.lineTo(x+w,y+h);
    ctx.stroke();
    var fs = ctx.fillStyle;
    ctx.fillStyle = "#000000";
    var tl = 16*text.length;
    ctx.fillText(text,x+(w/2)-(tl/4),y+(h/2)+4);
    ctx.fillStyle = fs;
}

function drawArrow(ctx,x1,y1,x2,y2){
    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.stroke();

    ctx.moveTo(x1,y1);
    ctx.lineTo(x1+3,y1-4);
    ctx.stroke();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x1+3,y1+4);
    ctx.stroke();

    ctx.moveTo(x2,y2);
    ctx.lineTo(x2-3,y2-4);
    ctx.stroke();
    ctx.moveTo(x2,y2);
    ctx.lineTo(x2-3,y2+4);
    ctx.stroke();
}

var c = document.getElementById("freelist");
var ctx = c.getContext("2d");
ctx.font="normal 12pt Sans";
ctx.fillStyle = "#F8D7BB";
ctx.strokeStyle = "#000000";

drawRect(ctx,"start",0,20,100,50);
drawRect(ctx,"memory block",150,20,200,50);
drawRect(ctx,"end",400,20,100,50);
drawArrow(ctx,80,45,165,45);
drawArrow(ctx,340,45,415,45);

ctx.fillStyle = "#000000";
ctx.fillText("Freelist",2,13);
</script>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// memory block structure</span>
</span><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">memory_block_t</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">memory_block_t</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">memory_block_t</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span> <span class="n">memory_block</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// free memory block list</span>
</span><span class='line'><span class="k">static</span> <span class="n">memory_block</span> <span class="n">freelist</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="n">null</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;(</span><span class="n">freelist</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">},</span>  <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;(</span><span class="n">freelist</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">null</span><span class="p">}</span> <span class="p">};</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">freelist_start</span> <span class="p">(</span><span class="n">freelist</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">next</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">freelist_begin</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;(</span><span class="n">freelist</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">freelist_end</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;(</span><span class="n">freelist</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Note that when memory block will be used by an application it needs to have only size value reserved because we don&rsquo;t need doubly linked pointers as it&rsquo;s not in a free block list. Thus we need a method to reserve memory block&rsquo;s size field when we return it to the application. In order to ease interaction with memory block structure and it&rsquo;s pointers let&rsquo;s define some useful macros that will help us elevate the task of specifying casts manually. Pointer arithmetic can be sometimes daunting and puzzling in <em>C</em> but if used correctly it&rsquo;s very powerful feature and macro system helps us do exactly that. We also need an easy way to link two memory blocks with each other and even sometimes replace those links so we&rsquo;ll define some macros for that kind of operations too.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// useful macros&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1>define byte_ptr(p) ((uint8_t*)p)&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>define shift_ptr(p,s) (byte_ptr(p)+s)&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>define shift_block_ptr(b,s) ((memory_block*)(shift_ptr(b,s)))&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>define block_data(b) (shift_ptr(b,sizeof(size_t)))&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>define data_block(p) (shift_block_ptr(p,-sizeof(size_t)))&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>define block_end(b) (shift_block_ptr(b,b->size))&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>define block_link(lb,rb) \&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>rb-&gt;prev = lb; \
</span><span class='line'>lb-&gt;next = rb;
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;h1>define block_link_left(lb,b) \&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>block_link(b-&gt;prev,lb) \
</span><span class='line'>block_link(lb,b)
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;h1>define block_link_right(b,rb) \&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>block_link(rb,b-&gt;next) \
</span><span class='line'>block_link(b,rb)
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;h1>define block_unlink(b) \&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>block_link(b-&gt;prev,b-&gt;next)
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;h1>define block_unlink_right(b) \&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>block_unlink(b-&gt;next);
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;h1>define block_replace(b,nb) \&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>block_link(b-&gt;prev,nb) \
</span><span class='line'>block_link(nb,b-&gt;next)
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Let&rsquo;s start with <em>malloc</em> function, first of all let&rsquo;s correct initial size and add to it <em>sizeof(size_t)</em> since each allocated by an application block will preserve it.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span><span class="o">*</span> <span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">s</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// check for 0 size</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">null</span><span class="p">;</span>
</span><span class='line'><span class="c1">// add size of size_t as we need to save size of memory block</span>
</span><span class='line'><span class="n">s</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">);</span>
</span><span class='line'><span class="c1">// find suitable memory size</span>
</span><span class='line'><span class="kt">size_t</span> <span class="n">ns</span> <span class="o">=</span> <span class="n">find_optimal_memory_size</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
Next as you can see we need to find an optimal size for requested size <em>s</em>. We&rsquo;ll use a famous trick with bitwise shifting value to right in order to get optimal size for our memory block starting with <em>MIN_BLOCK_SIZE</em>. So the sizes in <em>while</em> loop will go from 32, 64, 128, 256 and further.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// find optimal memory block size for size s</span>
</span><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="kt">size_t</span> <span class="nf">find_optimal_memory_size</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">s</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">size_t</span> <span class="n">suitable_size</span> <span class="o">=</span> <span class="n">MIN_BLOCK_SIZE</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="n">suitable_size</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">s</span><span class="p">)</span>
</span><span class='line'>    <span class="n">suitable_size</span> <span class="o">=</span> <span class="n">suitable_size</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="n">suitable_size</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Next we need to handle large memory blocks. We&rsquo;ll be allocating those using <em>mmap</em> <em>syscall</em> which gives us an arbitary memory block for requested size usually rounded to page size. In worst case we are loosing <em>PAGE_SIZE</em>-1 bytes, however for large memory blocks which we are going to handle separately we can ignore it because block might be resized using <em>mremap</em> <em>syscall</em> in the future reclaiming page which wasn&rsquo;t used entirely before.
Note: we&rsquo;ve also added definition of MMAP_SIZE to our initial value definitions and set it equal to 1 MB.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// if size is greater than or equals MMAP_SIZE we are going to use mmap</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">ns</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="n">MMAP_SIZE</span><span class="p">){</span>
</span><span class='line'>    <span class="kt">void</span><span class="o">*</span> <span class="n">m</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">,</span><span class="n">MAP_PRIVATE</span><span class="o">|</span><span class="n">MAP_ANONYMOUS</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">null</span><span class="p">;</span>
</span><span class='line'>    <span class="n">memory_block</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">memory_block</span><span class="o">*</span><span class="p">)</span><span class="n">m</span><span class="p">;</span>
</span><span class='line'>    <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>    <span class="n">lock</span>
</span><span class='line'>    <span class="n">mmap_size</span> <span class="o">+=</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>    <span class="n">unlock</span>
</span><span class='line'>    <span class="k">return</span> <span class="nf">block_data</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
As you&rsquo;ve already noticed we&rsquo;ve used strange <em>lock</em> and <em>unlock</em> macros there. That&rsquo;s because we&rsquo;ll also be counting overall <em>mmap</em> blocks in <em>mmap_size</em> variable purely for statistical purposes. However since <em>malloc</em> function can be called from different threads simultaneously we need a way to synchronize modifications to this variable. And not only this variable can be modified simultaneously. Unfortunately as we are striving for most efficiency we can&rsquo;t use immutable data structures for <em>freelist</em> and we need a way to concurrently modify it so that in the end all modifications would be consistent. Let&rsquo;s use atomic <a href="https://en.wikipedia.org/wiki/Spinlock">spinlock</a> for all our concurrency needs. For a description of what atomic spinlock is try reading <a href="https://idea.popcount.org/2012-09-12-reinventing-spinlocks/">Marek&rsquo;s Reinventing Spinlocks</a> as the code below was shamelessly copied from there. Also instead of simple freelist we could use lock-free doubly linked list data structure but since we are focusing our efforts on memory allocation I won&rsquo;t describe it in here.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// locking</span>
</span><span class='line'><span class="k">volatile</span> <span class="n">bool</span> <span class="n">locked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">spinlock</span><span class="p">(){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__sync_bool_compare_and_swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">locked</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)){</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">do</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">__sync_bool_compare_and_swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">locked</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</span><span class='line'>            <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="k">else</span><span class="p">{</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">10</span><span class="p">){</span>
</span><span class='line'>                <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>                <span class="n">sched_yield</span><span class="p">();</span>
</span><span class='line'>            <span class="p">}</span><span class="k">else</span>
</span><span class='line'>                <span class="o">++</span><span class="n">i</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">lock</span> <span class="n">spinlock</span><span class="p">();</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">unlock</span> <span class="err">\</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;&quot;</span> <span class="o">:::</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span> \
</span><span class='line'><span class="n">locked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Let&rsquo;s continue our effort with <em>malloc</em> function. Now we need to handle blocks with size less than <em>MMAP_SIZE</em></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">lock</span>
</span><span class='line'><span class="c1">// find free memory block</span>
</span><span class='line'><span class="n">memory_block</span><span class="o">*</span> <span class="n">block</span> <span class="o">=</span> <span class="n">find_suitable_block</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">block</span> <span class="o">!=</span> <span class="n">null</span><span class="p">){</span>
</span><span class='line'>    <span class="n">unlock</span>
</span><span class='line'>    <span class="c1">// shift pointer into data block pointer</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">block_data</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>In order to find suitable block from memory list we&rsquo;ll just look through it.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// find suitable memory block for size s</span>
</span><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="n">memory_block</span><span class="o">*</span> <span class="nf">find_suitable_block</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">ns</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">memory_block</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">freelist_start</span><span class="p">;</span>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="n">freelist_end</span><span class="p">){</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="n">ns</span><span class="p">){</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">split_memory_block</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">ns</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="n">null</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Now what if block is sufficient for our needs. We need to split it or return it whole if it&rsquo;s needed entirely. The half left will be added back to <em>freelist</em> if <em>remainder</em> is more than or equals <em>MIN_BLOCK_SIZE</em> since there is no way we could add a block with less size.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// split memory block into 2 pieces one of size s and the other is remainder e.g. memory_block_size-s</span>
</span><span class='line'><span class="c1">// if remainder is less than MIN_BLOCK_SIZE we just take whole block</span>
</span><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="n">memory_block</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">split_memory_block</span><span class="p">(</span><span class="n">memory_block</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">s</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">size_t</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">-</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">remainder</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="n">MIN_BLOCK_SIZE</span><span class="p">){</span>
</span><span class='line'>    <span class="n">memory_block</span><span class="o">*</span> <span class="n">nb</span> <span class="o">=</span> <span class="n">shift_block_ptr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">s</span><span class="p">);</span>
</span><span class='line'>    <span class="n">nb</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>
</span><span class='line'>    <span class="n">block_replace</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">nb</span><span class="p">);</span>
</span><span class='line'>    <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'>    <span class="n">block_unlink</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">return</span> <span class="n">b</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>But wait, what if there are no free memory blocks? Let&rsquo;s allocate some memory from heap using <em>sbrk</em> <em>syscall</em>. Now the difference with <em>sbrk</em> versus <em>mmap</em> is that <em>sbrk</em> allocates continuous virtual memory or simply speaking grows heap outward (note: stack grows inward and heap outward so when those two meet each other ka-boom!). For those of you who don&rsquo;t know what heap is try reading <a href="http://www.geeksforgeeks.org/memory-layout-of-c-program/">this</a>. Unfortunately <em>sbrk</em> is slower than <em>mmap</em> performance-wise, but we need a specific property of memory allocated using <em>sbrk</em> so we&rsquo;ll be using it exclusively for that. Each newly allocated block has higher memory address than previous one and both of them are adjacent. We&rsquo;ll use this property to always have a sorted freelist in order to connect adjacent memory blocks more easily and quicker. This is our way to fight memory fragmentation. Also in order to minimize number of <em>sbrk</em> calls we&rsquo;ll allocate memory by larger chunks specified in <em>ALLOC_SIZE</em> instead of just number of pages we need.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// no free memory blocks found</span>
</span><span class='line'><span class="c1">// we need to allocate new one that would be suitable for our needs using sbrk</span>
</span><span class='line'><span class="kt">size_t</span> <span class="n">pages_size</span> <span class="o">=</span> <span class="p">((</span><span class="n">ns</span><span class="o">/</span><span class="n">PAGE_SIZE</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">PAGE_SIZE</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">pages_size</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">ALLOC_SIZE</span><span class="p">)</span>
</span><span class='line'>    <span class="n">pages_size</span> <span class="o">=</span> <span class="n">ALLOC_SIZE</span><span class="p">;</span>
</span><span class='line'><span class="c1">// allocate memory with sbrk</span>
</span><span class='line'><span class="kt">void</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">sbrk</span><span class="p">(</span><span class="n">pages_size</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">){</span>
</span><span class='line'>    <span class="n">unlock</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">null</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Next after allocating new block using <em>sbrk</em> we just split it and add back to <em>freelist</em>. We are also counting the overall heap size allocated by <em>sbrk</em> calls just for stats. Also we save <em>heap_start</em> and <em>heap_end</em> in order to distinguish memory blocks allocated using <em>sbrk</em> from <em>mmap</em> blocks.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="n">memory_block</span><span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
</span><span class='line'><span class="n">heap_size</span> <span class="o">+=</span> <span class="n">pages_size</span><span class="p">;</span>
</span><span class='line'><span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">=</span> <span class="n">ns</span><span class="p">;</span>
</span><span class='line'><span class="n">heap_end</span> <span class="o">=</span> <span class="n">shift_block_ptr</span><span class="p">(</span><span class="n">block</span><span class="p">,</span><span class="n">pages_size</span><span class="p">);</span>
</span><span class='line'><span class="n">heap_start</span> <span class="o">=</span> <span class="n">shift_block_ptr</span><span class="p">(</span><span class="n">heap_end</span><span class="p">,</span><span class="o">-</span><span class="n">heap_size</span><span class="p">);</span>
</span><span class='line'><span class="n">ns</span> <span class="o">=</span> <span class="n">pages_size</span> <span class="o">-</span> <span class="n">ns</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">ns</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="n">MIN_BLOCK_SIZE</span><span class="p">){</span>
</span><span class='line'>    <span class="n">memory_block</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">shift_block_ptr</span><span class="p">(</span><span class="n">block</span><span class="p">,</span><span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>    <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">=</span> <span class="n">ns</span><span class="p">;</span>
</span><span class='line'>    <span class="n">add_block</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">unlock</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="n">block_data</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Now the only thing left is to add the free block to the <em>freelist</em>. This might sound trivial but we need to handle a little bit more complexity than there might seem. First of all we need to insert blocks in sorted order. Next after inserting free block we need to merge it with adjacent blocks near on the left and right from it, if those blocks are continuously allocated in virtual memory space.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// add block to free list</span>
</span><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">add_block</span><span class="p">(</span><span class="n">memory_block</span><span class="o">*</span> <span class="n">block</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span><span class="p">(</span><span class="n">freelist_start</span> <span class="o">!=</span> <span class="n">freelist_end</span><span class="p">){</span>
</span><span class='line'>    <span class="c1">// find superseding memory block</span>
</span><span class='line'>    <span class="c1">// and insert current one before it</span>
</span><span class='line'>    <span class="n">memory_block</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">freelist_start</span><span class="p">;</span>
</span><span class='line'>    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
</span><span class='line'>        <span class="c1">// superseding memory block will have higher memory address</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">block</span><span class="p">){</span>
</span><span class='line'>            <span class="n">block_link_left</span><span class="p">(</span><span class="n">block</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'>            <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="c1">// check if we hit end</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">next</span> <span class="o">==</span> <span class="n">freelist_end</span><span class="p">){</span>
</span><span class='line'>            <span class="n">block_link_right</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">block</span><span class="p">);</span>
</span><span class='line'>            <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'>            <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// merge adjacent blocks</span>
</span><span class='line'>    <span class="n">bool</span> <span class="n">merged</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>    <span class="k">while</span><span class="p">(</span><span class="n">merged</span><span class="p">){</span>
</span><span class='line'>        <span class="c1">// merge right adjacent block</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">block_end</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="o">==</span> <span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">next</span><span class="p">){</span>
</span><span class='line'>            <span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">+=</span> <span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">next</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">;</span>
</span><span class='line'>            <span class="n">block_unlink_right</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
</span><span class='line'>            <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="c1">// merge left adjacent block</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">block_end</span><span class="p">(</span><span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">prev</span><span class="p">)</span> <span class="o">==</span> <span class="n">block</span><span class="p">){</span>
</span><span class='line'>            <span class="n">block</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">prev</span><span class="p">;</span>
</span><span class='line'>            <span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">+=</span> <span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">next</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">;</span>
</span><span class='line'>            <span class="n">block_unlink_right</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
</span><span class='line'>            <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">merged</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'>    <span class="c1">// add first memory block</span>
</span><span class='line'>    <span class="n">memory_block</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">freelist_begin</span><span class="p">;</span>
</span><span class='line'>    <span class="n">block_link_right</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>That&rsquo;s it with <em>malloc</em> now let&rsquo;s write <em>free</em>. As you can see below we check if memory block is allocated using <em>mmap</em> and <em>munmap</em> it. Otherwise we add it back to <em>freelist</em>.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// mmap&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">is_mmap_block</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">heap_start</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="n">b</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">b</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">heap_end</span><span class="p">))</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">void</span> <span class="n">free</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// check for null pointer</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// shift pointer back into memory block pointer</span>
</span><span class='line'><span class="n">memory_block</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">data_block</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">lock</span>
</span><span class='line'><span class="nf">if</span><span class="p">(</span><span class="n">is_mmap_block</span><span class="p">(</span><span class="n">b</span><span class="p">)){</span>
</span><span class='line'>    <span class="n">mmap_size</span> <span class="o">-=</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">;</span>
</span><span class='line'>    <span class="n">unlock</span>
</span><span class='line'>    <span class="n">munmap</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// add removed block into freelist</span>
</span><span class='line'><span class="n">add_block</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
Finally we are checking the end of heap and give back free memory to operating system using <em>sbrk</em> with negative size if the size is at least <em>GIVE_BACK_SIZE</em> which we&rsquo;ve also added to initial values.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// give last memory block that isn&#39;t needed back to the operating system</span>
</span><span class='line'><span class="n">b</span> <span class="o">=</span> <span class="n">freelist_end</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">prev</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">block_end</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="n">heap_end</span><span class="p">){</span>
</span><span class='line'>    <span class="kt">intptr_t</span> <span class="n">inc</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">inc</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="n">GIVE_BACK_SIZE</span><span class="p">){</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="n">heap_start</span><span class="p">){</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="n">inc</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">GIVE_BACK_SIZE</span><span class="p">){</span>
</span><span class='line'>                <span class="n">inc</span> <span class="o">=</span> <span class="n">inc</span> <span class="o">-</span> <span class="n">GIVE_BACK_SIZE</span><span class="p">;</span>
</span><span class='line'>                <span class="n">sbrk</span><span class="p">(</span><span class="o">-</span><span class="n">inc</span><span class="p">);</span>
</span><span class='line'>                <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">=</span> <span class="n">GIVE_BACK_SIZE</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'>            <span class="n">block_unlink</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'>            <span class="n">sbrk</span><span class="p">(</span><span class="o">-</span><span class="n">inc</span><span class="p">);</span>
</span><span class='line'>            <span class="n">heap_size</span> <span class="o">-=</span> <span class="n">inc</span><span class="p">;</span>
</span><span class='line'>            <span class="n">heap_end</span> <span class="o">=</span> <span class="n">shift_block_ptr</span><span class="p">(</span><span class="n">heap_end</span><span class="p">,</span><span class="o">-</span><span class="n">inc</span><span class="p">);</span>
</span><span class='line'>            <span class="n">heap_start</span> <span class="o">=</span> <span class="n">shift_block_ptr</span><span class="p">(</span><span class="n">heap_end</span><span class="p">,</span><span class="o">-</span><span class="n">heap_size</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">unlock</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Next after <em>free</em> let&rsquo;s implement <em>realloc</em>. As you can see it mostly repeats malloc, however we are using <em>mremap</em> for <em>mmap</em> blocks since those are already allocated and we need to resize them.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">realloc</span><span class="p">(</span><span class="kt">void</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">s</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">null</span><span class="p">){</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">malloc</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">null</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// shift pointer back into memory block pointer</span>
</span><span class='line'><span class="n">memory_block</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">data_block</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// find out which new optimal size we need</span>
</span><span class='line'><span class="kt">size_t</span> <span class="n">ss</span> <span class="o">=</span> <span class="n">s</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">);</span>
</span><span class='line'><span class="kt">size_t</span> <span class="n">ns</span> <span class="o">=</span> <span class="n">find_optimal_memory_size</span><span class="p">(</span><span class="n">ss</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// if memory is mmap we need to use mremap</span>
</span><span class='line'><span class="n">lock</span>
</span><span class='line'><span class="nf">if</span><span class="p">(</span><span class="n">is_mmap_block</span><span class="p">(</span><span class="n">b</span><span class="p">)){</span>
</span><span class='line'>    <span class="n">mmap_size</span> <span class="o">-=</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">;</span>
</span><span class='line'>    <span class="n">mmap_size</span> <span class="o">+=</span> <span class="n">ss</span><span class="p">;</span>
</span><span class='line'>    <span class="n">unlock</span>
</span><span class='line'>    <span class="kt">void</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mremap</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">,</span><span class="n">ss</span><span class="p">,</span><span class="n">MREMAP_MAYMOVE</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">null</span><span class="p">;</span>
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">memory_block</span><span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
</span><span class='line'>    <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">=</span> <span class="n">ss</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">block_data</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Next we check if block already contains the necessary size or the size can be obtained by connecting adjacent blocks.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span><span class="p">(</span><span class="n">ns</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">MMAP_SIZE</span><span class="p">){</span>
</span><span class='line'>    <span class="c1">// check if size is already sufficient</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="n">ns</span><span class="p">){</span>
</span><span class='line'>        <span class="n">unlock</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">ifdef</span> <span class="n">MERGE_ADJ_ON_REALLOC</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>    <span class="c1">// try merging with adjacent blocks</span>
</span><span class='line'>    <span class="n">memory_block</span><span class="o">*</span> <span class="n">nb</span> <span class="o">=</span> <span class="n">merge_with_adjacent_block</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">ns</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">nb</span> <span class="o">!=</span> <span class="n">null</span><span class="p">){</span>
</span><span class='line'>        <span class="n">unlock</span>
</span><span class='line'>        <span class="c1">// shift pointer into data block pointer</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">block_data</span><span class="p">(</span><span class="n">nb</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">endif</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="p">}</span>
</span><span class='line'><span class="n">unlock</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Merging with adjacent block is quite complex operation thus we make it configurable so that if necessary we can always disable it. We handle both left and right adjacent cases. Left one is more complex and right one is simpler. Also we need to split block before connecting it with our initial one if the size has <em>remainder</em>, hence the complexity.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// merge with adjacent block so that overall new size would be s</span>
</span><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="n">memory_block</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">merge_with_adjacent_block</span><span class="p">(</span><span class="n">memory_block</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">block</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">s</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span><span class="p">(</span><span class="n">freelist_start</span> <span class="o">==</span> <span class="n">freelist_end</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">null</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">memory_block</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">freelist_start</span><span class="p">;</span>
</span><span class='line'><span class="n">memory_block</span><span class="o">*</span> <span class="n">be</span> <span class="o">=</span> <span class="n">block_end</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
</span><span class='line'><span class="k">do</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// left adjacent</span>
</span><span class='line'>    <span class="c1">// code is slightly more complex as we need to copy data over</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">block_end</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="n">block</span><span class="p">){</span>
</span><span class='line'>        <span class="k">if</span><span class="p">((</span><span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">+</span> <span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="n">s</span><span class="p">){</span>
</span><span class='line'>            <span class="kt">size_t</span> <span class="n">remainder</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">+</span> <span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>            <span class="c1">// we need to backup block pointers as they might be overwritten by memcpy</span>
</span><span class='line'>            <span class="n">memory_block</span><span class="o">*</span> <span class="n">temp_prev</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">prev</span><span class="p">;</span>
</span><span class='line'>            <span class="n">memory_block</span><span class="o">*</span> <span class="n">temp_next</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>            <span class="n">memcpy</span><span class="p">(</span><span class="n">block_data</span><span class="p">(</span><span class="n">b</span><span class="p">),</span><span class="n">block_data</span><span class="p">(</span><span class="n">block</span><span class="p">),</span> <span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">));</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="n">remainder</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="n">MIN_BLOCK_SIZE</span><span class="p">){</span>
</span><span class='line'>                <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>                <span class="n">memory_block</span><span class="o">*</span> <span class="n">nb</span> <span class="o">=</span> <span class="n">shift_block_ptr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">s</span><span class="p">);</span>
</span><span class='line'>                <span class="n">nb</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>
</span><span class='line'>                <span class="n">block_link</span><span class="p">(</span><span class="n">temp_prev</span><span class="p">,</span><span class="n">nb</span><span class="p">);</span>
</span><span class='line'>                <span class="n">block_link</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span><span class="n">temp_next</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'>                <span class="c1">// unfortunetly here we can&#39;t use b-&amp;gt;prev as </span>
</span><span class='line'>                <span class="c1">// it might have been overwritten by memcpy</span>
</span><span class='line'>                <span class="c1">// so we need to remove remaining block entirely using temporary pointers</span>
</span><span class='line'>                <span class="n">block_link</span><span class="p">(</span><span class="n">temp_prev</span><span class="p">,</span><span class="n">temp_next</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// right adjacent</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">be</span> <span class="o">==</span> <span class="n">b</span><span class="p">){</span>
</span><span class='line'>        <span class="k">if</span><span class="p">((</span><span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">+</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="n">s</span><span class="p">){</span>
</span><span class='line'>            <span class="kt">size_t</span> <span class="n">remainder</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">+</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="n">remainder</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="n">MIN_BLOCK_SIZE</span><span class="p">){</span>
</span><span class='line'>                <span class="n">memory_block</span><span class="o">*</span> <span class="n">nb</span> <span class="o">=</span> <span class="n">shift_block_ptr</span><span class="p">(</span><span class="n">block</span><span class="p">,</span><span class="n">s</span><span class="p">);</span>
</span><span class='line'>                <span class="n">nb</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>
</span><span class='line'>                <span class="n">block_replace</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">nb</span><span class="p">);</span>
</span><span class='line'>                <span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'>                <span class="n">block_unlink</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">block</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="n">freelist_end</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">b</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="n">be</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="n">null</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Finally we handle the case when there is no memory to merge and no to resize. We just allocate a new memory and copy data over into it. Afterwards we deallocate the previous memory block.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">void</span><span class="o">*</span> <span class="n">np</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">np</span> <span class="o">!=</span> <span class="n">null</span><span class="p">){</span>
</span><span class='line'>    <span class="c1">// copy old data block into new one</span>
</span><span class='line'>    <span class="n">memcpy</span><span class="p">(</span><span class="n">np</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">s</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">?</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">:</span> <span class="n">s</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// free old data block</span>
</span><span class='line'>    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// return newly allocated block</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">np</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="n">null</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Main work is done, remaining are just supplementary functions which are self explanatory.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span><span class="o">*</span> <span class="nf">calloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">nmemb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">nmemb</span><span class="o">*</span><span class="n">size</span><span class="p">;</span>
</span><span class='line'><span class="kt">void</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span>
</span><span class='line'>    <span class="n">memset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'><span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">void</span> <span class="n">print_block_info</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// shift pointer back into memory block pointer</span>
</span><span class='line'><span class="n">memory_block</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">data_block</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span><span class='line'><span class="n">lock</span>
</span><span class='line'><span class="nf">print_block</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'><span class="n">unlock</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">void</span> <span class="n">print_freelist</span><span class="p">(){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">lock</span>
</span><span class='line'><span class="n">printf</span><span class="p">(</span><span class="s">&quot;[heap size %d mb mmap_size %d mb, &quot;</span><span class="p">,(</span><span class="n">heap_size</span><span class="o">/</span><span class="p">(</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">)),(</span><span class="n">mmap_size</span><span class="o">/</span><span class="p">(</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">)));</span>
</span><span class='line'><span class="n">printf</span><span class="p">(</span><span class="s">&quot;freelist {&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">memory_block</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">freelist_start</span><span class="p">;</span>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="n">freelist_end</span><span class="p">){</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot; -&amp;gt; %p[%u|%p|%p]&quot;</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">,</span><span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">prev</span><span class="p">,</span><span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">next</span><span class="p">);</span>
</span><span class='line'>    <span class="c1">// detect infinite loop if any</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">next</span><span class="p">){</span>
</span><span class='line'>        <span class="n">printf</span><span class="p">(</span><span class="s">&quot; -&amp;gt; infinite loop</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">unlock</span>
</span><span class='line'><span class="n">printf</span><span class="p">(</span><span class="s">&quot; }</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Now to test/benchmark this whole thing I wrote a little application which is called <em>memsim</em> and is in <a href="https://github.com/troydm/mymalloc/">mymalloc</a> repo. It reads memory allocation simulation file without requesting any dynamic memory from filesystem and calls malloc, realloc, free and user provided custom stats function while counting timings and overall runtime without using any heap memory, internally allocating memory on stack using <em>alloca</em> function, so that it&rsquo;s workings don&rsquo;t affecting the testing process. In order to generate a complex memory simulation (which is just a simple text file) I wrote <em>genrandms</em> application that just does that. Now a little benchmarks to compare our malloc with glibc <em>malloc</em> on some intense scenario. <em>mymemsim</em> and <em>sysmemsim</em> are <em>memsim</em> executables linked against our malloc implementation and glibc malloc implementation.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;Single threaded scenario repeat 50 <span class="nb">times</span>&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;<span class="nv">$ </span>./mymemsim -t 1 -r 50 test.ms
</span><span class='line'>memory simulation took 3457ms
</span><span class='line'><span class="nv">$ </span>./sysmemsim -t 1 -r 50 test.ms
</span><span class='line'>memory simulation took 15157ms
</span></code></pre></td></tr></table></div></figure></notextile></div>
Now let&rsquo;s try a multithreading benchmark
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;Multi threaded 20 threads each repeat scenario 20 <span class="nb">times</span>&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;<span class="nv">$ </span>./mymemsim -t 20 -r 20 test.ms
</span><span class='line'>memory simulation took 64268ms
</span><span class='line'><span class="nv">$ </span>./sysmemsim -t 20 -r 20 test.ms
</span><span class='line'>memory simulation took 117117ms
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Unfortunately our malloc implementation is not as multithread friendly as it can be. We literally have one single global spinlock and we always lock it when we allocate memory. We can improve on that by splitting <em>freelist</em> into different partitions. This will sacrifice memory fragmentation fighting however will improve scalability over multiple processors as we can have different spinlocks for each partition and won&rsquo;t have to wait between them. The implementation is more complex and can be studied in <a href="https://github.com/troydm/mymalloc">mymalloc</a> repo <strong>mysmalloc.c</strong> file despite overall idea being simple. Let&rsquo;s benchmark it again.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;Multi threaded 20 threads each repeat scenario 20 <span class="nb">times</span>&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;<span class="nv">$ </span>./mymemsim -t 20 -r 20 test.ms
</span><span class='line'>memory simulation took 69510ms
</span><span class='line'><span class="nv">$ </span>./mysmemsim -t 20 -r 20 test.ms
</span><span class='line'>memory simulation took 43322ms
</span></code></pre></td></tr></table></div></figure></notextile></div>
As you can see we&rsquo;ve improved performance by partially sacrificing fragmentation, improving scalability, and partially increasing memory usage. Further improvements and experiments are possible as possibilities are countless however our time has run out so that&rsquo;s it for today folks! Have a nice memory hacking time!
<img src="http://i.imgur.com/qBrTRxO.png" alt="Smoking is bad for health" /></p>
]]></content>
  </entry>
  
</feed>
