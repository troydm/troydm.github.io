<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c | Troydm's Blog]]></title>
  <link href="http://troydm.github.io/blog/categories/c/atom.xml" rel="self"/>
  <link href="http://troydm.github.io/"/>
  <updated>2015-08-07T17:02:12+04:00</updated>
  <id>http://troydm.github.io/</id>
  <author>
    <name><![CDATA[Dmitry Geurkov]]></name>
    <email><![CDATA[d.geurkov@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Lifting Shadows off a Memory Allocation]]></title>
    <link href="http://troydm.github.io/blog/2015/08/03/lifting-shadows-off-a-memory-allocation/"/>
    <updated>2015-08-03T18:32:35+04:00</updated>
    <id>http://troydm.github.io/blog/2015/08/03/lifting-shadows-off-a-memory-allocation</id>
    <content type="html"><![CDATA[<p>Any sufficiently advanced technology is indistinguishable from magic or so they say. Today we are going to lift some shadows from
the very basic thing that is dynamic memory management in an application process. This knowledge is essential for anyone who wants to write his/her own <em>Programming Language</em> so gaining this knowledge is not an optional thing since it opens a whole new lever of understanding how dynamic memory is managed by application and is split between different applications. To do that we need to have some basic understanding of how the actual physical thing is used by operating system. For those who don&rsquo;t know anything about <em>Virtual Memory</em> or what <em>Memory Pages</em> are and which algorithms modern operating systems are using to manage those I suggest reading <a href="http://www.amazon.com/Operating-System-Concepts-Abraham-Silberschatz/dp/1118063333/">Operating Systems Concepts</a> and for those who want to know all the guts of how <em>Linux</em> does this under the hood there is <a href="http://www.amazon.com/Understanding-Linux-Kernel-Third-Daniel/dp/0596005652/">Understanding Linux Kernel</a>.
<img src="http://i.imgur.com/VphDXNR.png" alt="Police Loli" /></p>

<!--more-->


<p>For the lazy rest to put it simply physical memory is split into fixed size blocks which are called <em>Memory Pages</em> and depending on the computer architecture and operating system can be 2kb 4kb 16kb 32kb or even 4mb in size. Anytime we request memory from operating system using some <em>syscall</em> it&rsquo;s best to have the size divisible by the actual operating operating system&rsquo;s <em>Memory Page</em> size. If used simply this tends to waste a lot of memory so hence we need a way to be more efficient with our requests and also we need to think of a way to recycle the memory requested before which isn&rsquo;t already needed by the application. All this opens a new area for exploration which is called Memory Allocation Algorithms and is quite a hot topic because not only we need to manage the recycling complexity but also concurrency and parallelism of the actual algorithms to be more efficient with modern multi-processor computers.
Some notable examples of algorithm that do that and are used in real world are <a href="http://g.oswego.edu/dl/html/malloc.html">Doug Lea&rsquo;s malloc</a>, <a href="http://tlsf.baisoku.org/">TLSF</a> and <a href="http://www.canonware.com/jemalloc/">jemalloc</a>, also there are much more out there. In order to explore some basic ideas about memory allocators we&rsquo;ll write the simplest algorithm commonly called power of 2. The essential idea behind it is to split blocks of memory into sizes divisible by 2 such as 32, 64, 128 and etc. By doing so we could reuse already used blocks by breaking them into more smaller onces. For example 128 block can be broken into 2 blocks of 64 and each of them can also further be broken to 32 sized blocks.</p>

<p><canvas id="memoryBlock" width="400" height="75"></canvas></p>

<script>
var c = document.getElementById("memoryBlock");
var ctx = c.getContext("2d");
ctx.font="normal 12pt Sans";
ctx.fillStyle = "#F8D7BB";
ctx.strokeStyle = "#000000";
ctx.fillRect(0,0,400,75);
ctx.moveTo(0,0);
ctx.lineTo(400,0);
ctx.stroke();
ctx.moveTo(0,0);
ctx.lineTo(0,75);
ctx.stroke();
ctx.moveTo(0,75);
ctx.lineTo(400,75);
ctx.stroke();
ctx.moveTo(400,0);
ctx.lineTo(400,75);
ctx.stroke();
ctx.moveTo(0,25);
ctx.lineTo(400,25);
ctx.stroke();
ctx.moveTo(200,25);
ctx.lineTo(200,75);
ctx.stroke();
ctx.moveTo(100,50);
ctx.lineTo(100,75);
ctx.stroke();
ctx.moveTo(0,50);
ctx.lineTo(200,50);
ctx.stroke();
ctx.moveTo(300,50);
ctx.lineTo(300,75);
ctx.stroke();
ctx.moveTo(200,50);
ctx.lineTo(400,50);
ctx.stroke();
ctx.moveTo(200,50);
ctx.lineTo(400,50);
ctx.stroke();
ctx.fillStyle = "#000000";
ctx.fillText("128",185,18);
ctx.fillText("64",92,43);
ctx.fillText("64",292,43);
ctx.fillText("32",46,67);
ctx.fillText("32",148,67);
ctx.fillText("32",246,67);
ctx.fillText("32",338,67);
</script>


<p>In general this tends to waste a lot of memory and introduces memory fragmentation. In worst case scenario half of all requested memory is wasted but usually in real world cases the actual number is near 25%. The memory wasting cost has computing performance gain as the algorithm itself is not hard to implement and works faster than more complex but conservative ones. Hence we are going to write a simple memory allocator also commonly called <em>malloc</em> since this is the library function name used by standard <em>C</em> library for allocating dynamic memory of variable size for the application process. We are going to implement our version of that function and related functions. Our target platform will be <em>Linux</em> and <em>gcc</em> compiler since we aren&rsquo;t going to bother with portability as this will take much more time and effort. Final version of source code can be browsed in <a href="https://github.com/troydm/mymalloc">mymalloc</a> repo but I strongly encourage you to write the whole thing from scratch yourself just to better understand the actual processes under the hood.</p>

<p>First let&rsquo;s start with function definitions that we need to reimplement. Create a file called <strong>mymalloc.h</strong>. We&rsquo;ll also define some functions for debug/stats purposes as those will be helpful during development process. Note: all this functions are defined by glibc in linux so gcc will complain about them being redefined during compilation but you can ignore those messages.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">calloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">nmemb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">s</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">realloc</span><span class="p">(</span><span class="kt">void</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ns</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">free</span><span class="p">(</span><span class="kt">void</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">);</span>
</span><span class='line'><span class="c1">// for debug use only</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">print_block_info</span><span class="p">(</span><span class="kt">void</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">print_freelist</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Now let&rsquo;s create a file called <strong>mymalloc.c</strong> and define the actual functions. We&rsquo;ll start with some initial values which are provided by operating system. The defined values are self explaining however I need to clarify the choice with 32 bytes for minimum block size. Since we&rsquo;ll manage memory blocks as doubly linked list nodes, each memory block needs to have space for at least two pointers and one size value which can&rsquo;t be more than the pointer size so that&rsquo;s 3 pointers for each node. Maximum size for 3 pointers for 64-bit operating system is 8 bytes so it&rsquo;s overall 24 bytes however block size needs to be power of 2 value and nearest size is 2<sup>5</sup> hence 32.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// for code clarity for pointers we use null instead of 0&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1>define null 0&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;p>// initial values&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1>define PAGE_SIZE (sysconf(_SC_PAGESIZE))&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>define MIN_BLOCK_SIZE 32 // bytes&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>We need a place to save free memory blocks and a way to manage them so let&rsquo;s first describe what memory block is and define initial doubly linked list for it that will contain <em>start</em> and <em>end</em> nodes pointing at each other. Those nodes won&rsquo;t be used and are there just so that our code won&rsquo;t contain conditional <em>if</em> statements when handling nodes.</p>

<p><canvas id="freelist" width="600" height="75"></canvas></p>

<script>
function drawRect(ctx,text,x,y,w,h){
    ctx.fillRect(x,y,w,h);
    ctx.moveTo(x,y);
    ctx.lineTo(x,y+h);
    ctx.stroke();
    ctx.moveTo(x,y);
    ctx.lineTo(x+w,y);
    ctx.stroke();
    ctx.moveTo(x+w,y);
    ctx.lineTo(x+w,y+h);
    ctx.stroke();
    ctx.moveTo(x,y+h);
    ctx.lineTo(x+w,y+h);
    ctx.stroke();
    var fs = ctx.fillStyle;
    ctx.fillStyle = "#000000";
    var tl = 16*text.length;
    ctx.fillText(text,x+(w/2)-(tl/4),y+(h/2)+4);
    ctx.fillStyle = fs;
}

function drawArrow(ctx,x1,y1,x2,y2){
    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.stroke();

    ctx.moveTo(x1,y1);
    ctx.lineTo(x1+3,y1-4);
    ctx.stroke();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x1+3,y1+4);
    ctx.stroke();

    ctx.moveTo(x2,y2);
    ctx.lineTo(x2-3,y2-4);
    ctx.stroke();
    ctx.moveTo(x2,y2);
    ctx.lineTo(x2-3,y2+4);
    ctx.stroke();
}

var c = document.getElementById("freelist");
var ctx = c.getContext("2d");
ctx.font="normal 12pt Sans";
ctx.fillStyle = "#F8D7BB";
ctx.strokeStyle = "#000000";

drawRect(ctx,"start",0,20,100,50);
drawRect(ctx,"memory block",150,20,200,50);
drawRect(ctx,"end",400,20,100,50);
drawArrow(ctx,80,45,165,45);
drawArrow(ctx,340,45,415,45);

ctx.fillStyle = "#000000";
ctx.fillText("Freelist",2,13);
</script>


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// memory block structure</span>
</span><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">memory_block_t</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">memory_block_t</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">memory_block_t</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span> <span class="n">memory_block</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// free memory block list</span>
</span><span class='line'><span class="k">static</span> <span class="n">memory_block</span> <span class="n">freelist</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="n">null</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;(</span><span class="n">freelist</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">},</span>  <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;(</span><span class="n">freelist</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">null</span><span class="p">}</span> <span class="p">};</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">freelist_start</span> <span class="p">(</span><span class="n">freelist</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">next</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">freelist_begin</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;(</span><span class="n">freelist</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">freelist_end</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;(</span><span class="n">freelist</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Note that when memory block will be used by an application it needs to have only size value reserved because we don&rsquo;t need doubly linked pointers as it&rsquo;s not in a free block list. Thus we need a method to reserve memory block&rsquo;s size field when we return it to the application. In order to ease interaction with memory block structure and it&rsquo;s pointers let&rsquo;s define some useful macros that will help us elevate the task of specifying casts manually. Pointer arithmetic can be sometimes daunting and puzzling in <em>C</em> but if used correctly it&rsquo;s very powerful feature and macro system helps us do exactly that. We also need an easy way to link two memory blocks with each other and even sometimes replace those links so we&rsquo;ll define some macros for that kind of operations too.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// useful macros&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1>define byte_ptr(p) ((uint8_t*)p)&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>define shift_ptr(p,s) (byte_ptr(p)+s)&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>define shift_block_ptr(b,s) ((memory_block*)(shift_ptr(b,s)))&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>define block_data(b) (shift_ptr(b,sizeof(size_t)))&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>define data_block(p) (shift_block_ptr(p,-sizeof(size_t)))&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>define block_end(b) (shift_block_ptr(b,b->size))&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>define block_link(lb,rb) \&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>rb-&gt;prev = lb; \
</span><span class='line'>lb-&gt;next = rb;
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;h1>define block_link_left(lb,b) \&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>block_link(b-&gt;prev,lb) \
</span><span class='line'>block_link(lb,b)
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;h1>define block_link_right(b,rb) \&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>block_link(rb,b-&gt;next) \
</span><span class='line'>block_link(b,rb)
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;h1>define block_unlink(b) \&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>block_link(b-&gt;prev,b-&gt;next)
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;h1>define block_unlink_right(b) \&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>block_unlink(b-&gt;next);
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;h1>define block_replace(b,nb) \&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>block_link(b-&gt;prev,nb) \
</span><span class='line'>block_link(nb,b-&gt;next)
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Let&rsquo;s start with <em>malloc</em> function, first of all let&rsquo;s correct initial size and add to it <em>sizeof(size_t)</em> since each allocated by an application block will preserve it.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span><span class="o">*</span> <span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">s</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// check for 0 size</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">null</span><span class="p">;</span>
</span><span class='line'><span class="c1">// add size of size_t as we need to save size of memory block</span>
</span><span class='line'><span class="n">s</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">);</span>
</span><span class='line'><span class="c1">// find suitable memory size</span>
</span><span class='line'><span class="kt">size_t</span> <span class="n">ns</span> <span class="o">=</span> <span class="n">find_optimal_memory_size</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
Next as you can see we need to find an optimal size for requested size <em>s</em>. We&rsquo;ll use a famous trick with bitwise shifting value to right in order to get optimal size for our memory block starting with <em>MIN_BLOCK_SIZE</em>. So the sizes in <em>while</em> loop will go from 32, 64, 128, 256 and further.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// find optimal memory block size for size s</span>
</span><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="kt">size_t</span> <span class="nf">find_optimal_memory_size</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">s</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">size_t</span> <span class="n">suitable_size</span> <span class="o">=</span> <span class="n">MIN_BLOCK_SIZE</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="n">suitable_size</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">s</span><span class="p">)</span>
</span><span class='line'>    <span class="n">suitable_size</span> <span class="o">=</span> <span class="n">suitable_size</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="n">suitable_size</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Next we need to handle large memory blocks. We&rsquo;ll be allocating those using <em>mmap</em> <em>syscall</em> which gives us an arbitary memory block for requested size usually rounded to page size. In worst case we are loosing <em>PAGE_SIZE</em>-1 bytes, however for large memory blocks which we are going to handle separately we can ignore it because block might be resized using <em>mremap</em> <em>syscall</em> in the future reclaiming page which wasn&rsquo;t used entirely before.
Note: we&rsquo;ve also added definition of MMAP_SIZE to our initial value definitions and set it equal to 1 MB.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// if size is greater than or equals MMAP_SIZE we are going to use mmap</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">ns</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="n">MMAP_SIZE</span><span class="p">){</span>
</span><span class='line'>    <span class="kt">void</span><span class="o">*</span> <span class="n">m</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">,</span><span class="n">MAP_PRIVATE</span><span class="o">|</span><span class="n">MAP_ANONYMOUS</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">m</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">null</span><span class="p">;</span>
</span><span class='line'>    <span class="n">memory_block</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">memory_block</span><span class="o">*</span><span class="p">)</span><span class="n">m</span><span class="p">;</span>
</span><span class='line'>    <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>    <span class="n">lock</span>
</span><span class='line'>    <span class="n">mmap_size</span> <span class="o">+=</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>    <span class="n">unlock</span>
</span><span class='line'>    <span class="k">return</span> <span class="nf">block_data</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
As you&rsquo;ve already noticed we&rsquo;ve used strange <em>lock</em> and <em>unlock</em> macros there. That&rsquo;s because we&rsquo;ll also be counting overall <em>mmap</em> blocks in <em>mmap_size</em> variable purely for statistical purposes. However since <em>malloc</em> function can be called from different threads simultaneously we need a way to synchronize modifications to this variable. And not only this variable can be modified simultaneously. Unfortunately as we are striving for most efficiency we can&rsquo;t use immutable data structures for <em>freelist</em> and we need a way to concurrently modify it so that in the end all modifications would be consistent. Let&rsquo;s use atomic <a href="https://en.wikipedia.org/wiki/Spinlock">spinlock</a> for all our concurrency needs. For a description of what atomic spinlock is try reading <a href="https://idea.popcount.org/2012-09-12-reinventing-spinlocks/">Marek&rsquo;s Reinventing Spinlocks</a> as the code below was shamelessly copied from there. Also instead of simple freelist we could use lock-free doubly linked list data structure but since we are focusing our efforts on memory allocation I won&rsquo;t describe it in here.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// locking</span>
</span><span class='line'><span class="k">volatile</span> <span class="n">bool</span> <span class="n">locked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">spinlock</span><span class="p">(){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">__sync_bool_compare_and_swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">locked</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)){</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">do</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">__sync_bool_compare_and_swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="n">locked</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</span><span class='line'>            <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="k">else</span><span class="p">{</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">10</span><span class="p">){</span>
</span><span class='line'>                <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>                <span class="n">sched_yield</span><span class="p">();</span>
</span><span class='line'>            <span class="p">}</span><span class="k">else</span>
</span><span class='line'>                <span class="o">++</span><span class="n">i</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">lock</span> <span class="n">spinlock</span><span class="p">();</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">unlock</span> <span class="err">\</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span><span class="s">&quot;&quot;</span> <span class="o">:::</span> <span class="s">&quot;memory&quot;</span><span class="p">);</span> \
</span><span class='line'><span class="n">locked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Let&rsquo;s continue our effort with <em>malloc</em> function. Now we need to handle blocks with size less than <em>MMAP_SIZE</em></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">lock</span>
</span><span class='line'><span class="c1">// find free memory block</span>
</span><span class='line'><span class="n">memory_block</span><span class="o">*</span> <span class="n">block</span> <span class="o">=</span> <span class="n">find_suitable_block</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">block</span> <span class="o">!=</span> <span class="n">null</span><span class="p">){</span>
</span><span class='line'>    <span class="n">unlock</span>
</span><span class='line'>    <span class="c1">// shift pointer into data block pointer</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">block_data</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>In order to find suitable block from memory list we&rsquo;ll just look through it.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// find suitable memory block for size s</span>
</span><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="n">memory_block</span><span class="o">*</span> <span class="nf">find_suitable_block</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">ns</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">memory_block</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">freelist_start</span><span class="p">;</span>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="n">freelist_end</span><span class="p">){</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="n">ns</span><span class="p">){</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">split_memory_block</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">ns</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="n">null</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Now what if block is sufficient for our needs. We need to split it or return it whole if it&rsquo;s needed entirely. The half left will be added back to <em>freelist</em> if <em>remainder</em> is more than or equals <em>MIN_BLOCK_SIZE</em> since there is no way we could add a block with less size.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// split memory block into 2 pieces one of size s and the other is remainder e.g. memory_block_size-s</span>
</span><span class='line'><span class="c1">// if remainder is less than MIN_BLOCK_SIZE we just take whole block</span>
</span><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="n">memory_block</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">split_memory_block</span><span class="p">(</span><span class="n">memory_block</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">s</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">size_t</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">-</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">remainder</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="n">MIN_BLOCK_SIZE</span><span class="p">){</span>
</span><span class='line'>    <span class="n">memory_block</span><span class="o">*</span> <span class="n">nb</span> <span class="o">=</span> <span class="n">shift_block_ptr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">s</span><span class="p">);</span>
</span><span class='line'>    <span class="n">nb</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>
</span><span class='line'>    <span class="n">block_replace</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">nb</span><span class="p">);</span>
</span><span class='line'>    <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'>    <span class="n">block_unlink</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">return</span> <span class="n">b</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>But wait, what if there are no free memory blocks? Let&rsquo;s allocate some memory from heap using <em>sbrk</em> <em>syscall</em>. Now the difference with <em>sbrk</em> versus <em>mmap</em> is that <em>sbrk</em> allocates continuous virtual memory or simply speaking grows heap outward (note: stack grows inward and heap outward so when those two meet each other ka-boom!). For those of you who don&rsquo;t know what heap is try reading <a href="http://www.geeksforgeeks.org/memory-layout-of-c-program/">this</a>. Unfortunately <em>sbrk</em> is slower than <em>mmap</em> performance-wise, but we need a specific property of memory allocated using <em>sbrk</em> so we&rsquo;ll be using it exclusively for that. Each newly allocated block has higher memory address than previous one and both of them are adjacent. We&rsquo;ll use this property to always have a sorted freelist in order to connect adjacent memory blocks more easily and quicker. This is our way to fight memory fragmentation. Also in order to minimize number of <em>sbrk</em> calls we&rsquo;ll allocate memory by larger chunks specified in <em>ALLOC_SIZE</em> instead of just number of pages we need.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// no free memory blocks found</span>
</span><span class='line'><span class="c1">// we need to allocate new one that would be suitable for our needs using sbrk</span>
</span><span class='line'><span class="kt">size_t</span> <span class="n">pages_size</span> <span class="o">=</span> <span class="p">((</span><span class="n">ns</span><span class="o">/</span><span class="n">PAGE_SIZE</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">PAGE_SIZE</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">pages_size</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">ALLOC_SIZE</span><span class="p">)</span>
</span><span class='line'>    <span class="n">pages_size</span> <span class="o">=</span> <span class="n">ALLOC_SIZE</span><span class="p">;</span>
</span><span class='line'><span class="c1">// allocate memory with sbrk</span>
</span><span class='line'><span class="kt">void</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">sbrk</span><span class="p">(</span><span class="n">pages_size</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">){</span>
</span><span class='line'>    <span class="n">unlock</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">null</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Next after allocating new block using <em>sbrk</em> we just split it and add back to <em>freelist</em>. We are also counting the overall heap size allocated by <em>sbrk</em> calls just for stats. Also we save <em>heap_start</em> and <em>heap_end</em> in order to distinguish memory blocks allocated using <em>sbrk</em> from <em>mmap</em> blocks.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="n">memory_block</span><span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
</span><span class='line'><span class="n">heap_size</span> <span class="o">+=</span> <span class="n">pages_size</span><span class="p">;</span>
</span><span class='line'><span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">=</span> <span class="n">ns</span><span class="p">;</span>
</span><span class='line'><span class="n">heap_end</span> <span class="o">=</span> <span class="n">shift_block_ptr</span><span class="p">(</span><span class="n">block</span><span class="p">,</span><span class="n">pages_size</span><span class="p">);</span>
</span><span class='line'><span class="n">heap_start</span> <span class="o">=</span> <span class="n">shift_block_ptr</span><span class="p">(</span><span class="n">heap_end</span><span class="p">,</span><span class="o">-</span><span class="n">heap_size</span><span class="p">);</span>
</span><span class='line'><span class="n">ns</span> <span class="o">=</span> <span class="n">pages_size</span> <span class="o">-</span> <span class="n">ns</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">ns</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="n">MIN_BLOCK_SIZE</span><span class="p">){</span>
</span><span class='line'>    <span class="n">memory_block</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">shift_block_ptr</span><span class="p">(</span><span class="n">block</span><span class="p">,</span><span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>    <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">=</span> <span class="n">ns</span><span class="p">;</span>
</span><span class='line'>    <span class="n">add_block</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">unlock</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="n">block_data</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Now the only thing left is to add the free block to the <em>freelist</em>. This might sound trivial but we need to handle a little bit more complexity than there might seem. First of all we need to insert blocks in sorted order. Next after inserting free block we need to merge it with adjacent blocks near on the left and right from it, if those blocks are continuously allocated in virtual memory space.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// add block to free list</span>
</span><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">add_block</span><span class="p">(</span><span class="n">memory_block</span><span class="o">*</span> <span class="n">block</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span><span class="p">(</span><span class="n">freelist_start</span> <span class="o">!=</span> <span class="n">freelist_end</span><span class="p">){</span>
</span><span class='line'>    <span class="c1">// find superseding memory block</span>
</span><span class='line'>    <span class="c1">// and insert current one before it</span>
</span><span class='line'>    <span class="n">memory_block</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">freelist_start</span><span class="p">;</span>
</span><span class='line'>    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
</span><span class='line'>        <span class="c1">// superseding memory block will have higher memory address</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">block</span><span class="p">){</span>
</span><span class='line'>            <span class="n">block_link_left</span><span class="p">(</span><span class="n">block</span><span class="p">,</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'>            <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="c1">// check if we hit end</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">next</span> <span class="o">==</span> <span class="n">freelist_end</span><span class="p">){</span>
</span><span class='line'>            <span class="n">block_link_right</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">block</span><span class="p">);</span>
</span><span class='line'>            <span class="k">break</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'>            <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// merge adjacent blocks</span>
</span><span class='line'>    <span class="n">bool</span> <span class="n">merged</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>    <span class="k">while</span><span class="p">(</span><span class="n">merged</span><span class="p">){</span>
</span><span class='line'>        <span class="c1">// merge right adjacent block</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">block_end</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="o">==</span> <span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">next</span><span class="p">){</span>
</span><span class='line'>            <span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">+=</span> <span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">next</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">;</span>
</span><span class='line'>            <span class="n">block_unlink_right</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
</span><span class='line'>            <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="c1">// merge left adjacent block</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">block_end</span><span class="p">(</span><span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">prev</span><span class="p">)</span> <span class="o">==</span> <span class="n">block</span><span class="p">){</span>
</span><span class='line'>            <span class="n">block</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">prev</span><span class="p">;</span>
</span><span class='line'>            <span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">+=</span> <span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">next</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">;</span>
</span><span class='line'>            <span class="n">block_unlink_right</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
</span><span class='line'>            <span class="k">continue</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">merged</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'>    <span class="c1">// add first memory block</span>
</span><span class='line'>    <span class="n">memory_block</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">freelist_begin</span><span class="p">;</span>
</span><span class='line'>    <span class="n">block_link_right</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>That&rsquo;s it with <em>malloc</em> now let&rsquo;s write <em>free</em>. As you can see below we check if memory block is allocated using <em>mmap</em> and <em>munmap</em> it. Otherwise we add it back to <em>freelist</em>.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// mmap&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">is_mmap_block</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">heap_start</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="n">b</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">b</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">heap_end</span><span class="p">))</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">void</span> <span class="n">free</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// check for null pointer</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">null</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// shift pointer back into memory block pointer</span>
</span><span class='line'><span class="n">memory_block</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">data_block</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">lock</span>
</span><span class='line'><span class="nf">if</span><span class="p">(</span><span class="n">is_mmap_block</span><span class="p">(</span><span class="n">b</span><span class="p">)){</span>
</span><span class='line'>    <span class="n">mmap_size</span> <span class="o">-=</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">;</span>
</span><span class='line'>    <span class="n">unlock</span>
</span><span class='line'>    <span class="n">munmap</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// add removed block into freelist</span>
</span><span class='line'><span class="n">add_block</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
Finally we are checking the end of heap and give back free memory to operating system using <em>sbrk</em> with negative size if the size is at least <em>GIVE_BACK_SIZE</em> which we&rsquo;ve also added to initial values.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// give last memory block that isn&#39;t needed back to the operating system</span>
</span><span class='line'><span class="n">b</span> <span class="o">=</span> <span class="n">freelist_end</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">prev</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">block_end</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="n">heap_end</span><span class="p">){</span>
</span><span class='line'>    <span class="kt">intptr_t</span> <span class="n">inc</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">inc</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="n">GIVE_BACK_SIZE</span><span class="p">){</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="n">heap_start</span><span class="p">){</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="n">inc</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">GIVE_BACK_SIZE</span><span class="p">){</span>
</span><span class='line'>                <span class="n">inc</span> <span class="o">=</span> <span class="n">inc</span> <span class="o">-</span> <span class="n">GIVE_BACK_SIZE</span><span class="p">;</span>
</span><span class='line'>                <span class="n">sbrk</span><span class="p">(</span><span class="o">-</span><span class="n">inc</span><span class="p">);</span>
</span><span class='line'>                <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">=</span> <span class="n">GIVE_BACK_SIZE</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'>            <span class="n">block_unlink</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'>            <span class="n">sbrk</span><span class="p">(</span><span class="o">-</span><span class="n">inc</span><span class="p">);</span>
</span><span class='line'>            <span class="n">heap_size</span> <span class="o">-=</span> <span class="n">inc</span><span class="p">;</span>
</span><span class='line'>            <span class="n">heap_end</span> <span class="o">=</span> <span class="n">shift_block_ptr</span><span class="p">(</span><span class="n">heap_end</span><span class="p">,</span><span class="o">-</span><span class="n">inc</span><span class="p">);</span>
</span><span class='line'>            <span class="n">heap_start</span> <span class="o">=</span> <span class="n">shift_block_ptr</span><span class="p">(</span><span class="n">heap_end</span><span class="p">,</span><span class="o">-</span><span class="n">heap_size</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">unlock</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Next after <em>free</em> let&rsquo;s implement <em>realloc</em>. As you can see it mostly repeats malloc, however we are using <em>mremap</em> for <em>mmap</em> blocks since those are already allocated and we need to resize them.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">realloc</span><span class="p">(</span><span class="kt">void</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">s</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">null</span><span class="p">){</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">malloc</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span><span class='line'>    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">null</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// shift pointer back into memory block pointer</span>
</span><span class='line'><span class="n">memory_block</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">data_block</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// find out which new optimal size we need</span>
</span><span class='line'><span class="kt">size_t</span> <span class="n">ss</span> <span class="o">=</span> <span class="n">s</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">);</span>
</span><span class='line'><span class="kt">size_t</span> <span class="n">ns</span> <span class="o">=</span> <span class="n">find_optimal_memory_size</span><span class="p">(</span><span class="n">ss</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// if memory is mmap we need to use mremap</span>
</span><span class='line'><span class="n">lock</span>
</span><span class='line'><span class="nf">if</span><span class="p">(</span><span class="n">is_mmap_block</span><span class="p">(</span><span class="n">b</span><span class="p">)){</span>
</span><span class='line'>    <span class="n">mmap_size</span> <span class="o">-=</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">;</span>
</span><span class='line'>    <span class="n">mmap_size</span> <span class="o">+=</span> <span class="n">ss</span><span class="p">;</span>
</span><span class='line'>    <span class="n">unlock</span>
</span><span class='line'>    <span class="kt">void</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mremap</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">,</span><span class="n">ss</span><span class="p">,</span><span class="n">MREMAP_MAYMOVE</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">null</span><span class="p">;</span>
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">memory_block</span><span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
</span><span class='line'>    <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">=</span> <span class="n">ss</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">block_data</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Next we check if block already contains the necessary size or the size can be obtained by connecting adjacent blocks.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span><span class="p">(</span><span class="n">ns</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="n">MMAP_SIZE</span><span class="p">){</span>
</span><span class='line'>    <span class="c1">// check if size is already sufficient</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="n">ns</span><span class="p">){</span>
</span><span class='line'>        <span class="n">unlock</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">ifdef</span> <span class="n">MERGE_ADJ_ON_REALLOC</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>    <span class="c1">// try merging with adjacent blocks</span>
</span><span class='line'>    <span class="n">memory_block</span><span class="o">*</span> <span class="n">nb</span> <span class="o">=</span> <span class="n">merge_with_adjacent_block</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">ns</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">nb</span> <span class="o">!=</span> <span class="n">null</span><span class="p">){</span>
</span><span class='line'>        <span class="n">unlock</span>
</span><span class='line'>        <span class="c1">// shift pointer into data block pointer</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">block_data</span><span class="p">(</span><span class="n">nb</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">endif</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="p">}</span>
</span><span class='line'><span class="n">unlock</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Merging with adjacent block is quite complex operation thus we make it configurable so that if necessary we can always disable it. We handle both left and right adjacent cases. Left one is more complex and right one is simpler. Also we need to split block before connecting it with our initial one if the size has <em>remainder</em>, hence the complexity.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="c1">// merge with adjacent block so that overall new size would be s</span>
</span><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="n">memory_block</span><span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">merge_with_adjacent_block</span><span class="p">(</span><span class="n">memory_block</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">block</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">s</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span><span class="p">(</span><span class="n">freelist_start</span> <span class="o">==</span> <span class="n">freelist_end</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">null</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">memory_block</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">freelist_start</span><span class="p">;</span>
</span><span class='line'><span class="n">memory_block</span><span class="o">*</span> <span class="n">be</span> <span class="o">=</span> <span class="n">block_end</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
</span><span class='line'><span class="k">do</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// left adjacent</span>
</span><span class='line'>    <span class="c1">// code is slightly more complex as we need to copy data over</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">block_end</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="n">block</span><span class="p">){</span>
</span><span class='line'>        <span class="k">if</span><span class="p">((</span><span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">+</span> <span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="n">s</span><span class="p">){</span>
</span><span class='line'>            <span class="kt">size_t</span> <span class="n">remainder</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">+</span> <span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>            <span class="c1">// we need to backup block pointers as they might be overwritten by memcpy</span>
</span><span class='line'>            <span class="n">memory_block</span><span class="o">*</span> <span class="n">temp_prev</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">prev</span><span class="p">;</span>
</span><span class='line'>            <span class="n">memory_block</span><span class="o">*</span> <span class="n">temp_next</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>            <span class="n">memcpy</span><span class="p">(</span><span class="n">block_data</span><span class="p">(</span><span class="n">b</span><span class="p">),</span><span class="n">block_data</span><span class="p">(</span><span class="n">block</span><span class="p">),</span> <span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">));</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="n">remainder</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="n">MIN_BLOCK_SIZE</span><span class="p">){</span>
</span><span class='line'>                <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>                <span class="n">memory_block</span><span class="o">*</span> <span class="n">nb</span> <span class="o">=</span> <span class="n">shift_block_ptr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">s</span><span class="p">);</span>
</span><span class='line'>                <span class="n">nb</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>
</span><span class='line'>                <span class="n">block_link</span><span class="p">(</span><span class="n">temp_prev</span><span class="p">,</span><span class="n">nb</span><span class="p">);</span>
</span><span class='line'>                <span class="n">block_link</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span><span class="n">temp_next</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'>                <span class="c1">// unfortunetly here we can&#39;t use b-&amp;gt;prev as </span>
</span><span class='line'>                <span class="c1">// it might have been overwritten by memcpy</span>
</span><span class='line'>                <span class="c1">// so we need to remove remaining block entirely using temporary pointers</span>
</span><span class='line'>                <span class="n">block_link</span><span class="p">(</span><span class="n">temp_prev</span><span class="p">,</span><span class="n">temp_next</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// right adjacent</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">be</span> <span class="o">==</span> <span class="n">b</span><span class="p">){</span>
</span><span class='line'>        <span class="k">if</span><span class="p">((</span><span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">+</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="n">s</span><span class="p">){</span>
</span><span class='line'>            <span class="kt">size_t</span> <span class="n">remainder</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">+</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="n">remainder</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="n">MIN_BLOCK_SIZE</span><span class="p">){</span>
</span><span class='line'>                <span class="n">memory_block</span><span class="o">*</span> <span class="n">nb</span> <span class="o">=</span> <span class="n">shift_block_ptr</span><span class="p">(</span><span class="n">block</span><span class="p">,</span><span class="n">s</span><span class="p">);</span>
</span><span class='line'>                <span class="n">nb</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>
</span><span class='line'>                <span class="n">block_replace</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">nb</span><span class="p">);</span>
</span><span class='line'>                <span class="n">block</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'>                <span class="n">block_unlink</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">block</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="n">freelist_end</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">b</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span><span class="o">=</span> <span class="n">be</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="n">null</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Finally we handle the case when there is no memory to merge and no to resize. We just allocate a new memory and copy data over into it. Afterwards we deallocate the previous memory block.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">void</span><span class="o">*</span> <span class="n">np</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">np</span> <span class="o">!=</span> <span class="n">null</span><span class="p">){</span>
</span><span class='line'>    <span class="c1">// copy old data block into new one</span>
</span><span class='line'>    <span class="n">memcpy</span><span class="p">(</span><span class="n">np</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">s</span> <span class="o">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">?</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span> <span class="o">:</span> <span class="n">s</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// free old data block</span>
</span><span class='line'>    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// return newly allocated block</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">np</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="n">null</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Main work is done, remaining are just supplementary functions which are self explanatory.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">void</span><span class="o">*</span> <span class="nf">calloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">nmemb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">nmemb</span><span class="o">*</span><span class="n">size</span><span class="p">;</span>
</span><span class='line'><span class="kt">void</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span>
</span><span class='line'>    <span class="n">memset</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'><span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">void</span> <span class="n">print_block_info</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="c1">// shift pointer back into memory block pointer</span>
</span><span class='line'><span class="n">memory_block</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">data_block</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span><span class='line'><span class="n">lock</span>
</span><span class='line'><span class="nf">print_block</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span><span class='line'><span class="n">unlock</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">void</span> <span class="n">print_freelist</span><span class="p">(){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">lock</span>
</span><span class='line'><span class="n">printf</span><span class="p">(</span><span class="s">&quot;[heap size %d mb mmap_size %d mb, &quot;</span><span class="p">,(</span><span class="n">heap_size</span><span class="o">/</span><span class="p">(</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">)),(</span><span class="n">mmap_size</span><span class="o">/</span><span class="p">(</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">)));</span>
</span><span class='line'><span class="n">printf</span><span class="p">(</span><span class="s">&quot;freelist {&quot;</span><span class="p">);</span>
</span><span class='line'><span class="n">memory_block</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="n">freelist_start</span><span class="p">;</span>
</span><span class='line'><span class="k">while</span><span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="n">freelist_end</span><span class="p">){</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot; -&amp;gt; %p[%u|%p|%p]&quot;</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">size</span><span class="p">,</span><span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">prev</span><span class="p">,</span><span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">next</span><span class="p">);</span>
</span><span class='line'>    <span class="c1">// detect infinite loop if any</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">next</span><span class="p">){</span>
</span><span class='line'>        <span class="n">printf</span><span class="p">(</span><span class="s">&quot; -&amp;gt; infinite loop</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">unlock</span>
</span><span class='line'><span class="n">printf</span><span class="p">(</span><span class="s">&quot; }</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Now to test/benchmark this whole thing I wrote a little application which is called <em>memsim</em> and is in <a href="https://github.com/troydm/mymalloc/">mymalloc</a> repo. It reads memory allocation simulation file without requesting any dynamic memory from filesystem and calls malloc, realloc, free and user provided custom stats function while counting timings and overall runtime without using any heap memory, internally allocating memory on stack using <em>alloca</em> function, so that it&rsquo;s workings don&rsquo;t affecting the testing process. In order to generate a complex memory simulation (which is just a simple text file) I wrote <em>genrandms</em> application that just does that. Now a little benchmarks to compare our malloc with glibc <em>malloc</em> on some intense scenario. <em>mymemsim</em> and <em>sysmemsim</em> are <em>memsim</em> executables linked against our malloc implementation and glibc malloc implementation.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;Single threaded scenario repeat 50 <span class="nb">times</span>&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;<span class="nv">$ </span>./mymemsim -t 1 -r 50 test.ms
</span><span class='line'>memory simulation took 3457ms
</span><span class='line'><span class="nv">$ </span>./sysmemsim -t 1 -r 50 test.ms
</span><span class='line'>memory simulation took 15157ms
</span></code></pre></td></tr></table></div></figure></notextile></div>
Now let&rsquo;s try a multithreading benchmark
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;Multi threaded 20 threads each repeat scenario 20 <span class="nb">times</span>&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;<span class="nv">$ </span>./mymemsim -t 20 -r 20 test.ms
</span><span class='line'>memory simulation took 64268ms
</span><span class='line'><span class="nv">$ </span>./sysmemsim -t 20 -r 20 test.ms
</span><span class='line'>memory simulation took 117117ms
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Unfortunately our malloc implementation is not as multithread friendly as it can be. We literally have one single global spinlock and we always lock it when we allocate memory. We can improve on that by splitting <em>freelist</em> into different partitions. This will sacrifice memory fragmentation fighting however will improve scalability over multiple processors as we can have different spinlocks for each partition and won&rsquo;t have to wait between them. The implementation is more complex and can be studied in <a href="https://github.com/troydm/mymalloc">mymalloc</a> repo <strong>mysmalloc.c</strong> file despite overall idea being simple. Let&rsquo;s benchmark it again.
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;Multi threaded 20 threads each repeat scenario 20 <span class="nb">times</span>&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;<span class="nv">$ </span>./mymemsim -t 20 -r 20 test.ms
</span><span class='line'>memory simulation took 69510ms
</span><span class='line'><span class="nv">$ </span>./mysmemsim -t 20 -r 20 test.ms
</span><span class='line'>memory simulation took 43322ms
</span></code></pre></td></tr></table></div></figure></notextile></div>
As you can see we&rsquo;ve improved performance by partially sacrificing fragmentation, improving scalability, and partially increasing memory usage. Further improvements and experiments are possible as possibilities are countless however our time has run out so that&rsquo;s it for today folks! Have a nice memory hacking time!
<img src="http://i.imgur.com/qBrTRxO.png" alt="Smoking is bad for health" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hosting your own remote private torrent tracker]]></title>
    <link href="http://troydm.github.io/blog/2013/04/24/hosting-your-own-remote-private-torrent-tracker/"/>
    <updated>2013-04-24T22:05:00+04:00</updated>
    <id>http://troydm.github.io/blog/2013/04/24/hosting-your-own-remote-private-torrent-tracker</id>
    <content type="html"><![CDATA[<p>Ever wanted to share a really big file (more than 4 GB) with someone without a hassle of uploading it to some file upload server?</p>

<p><a href="http://bittorrent.org/">BitTorrent</a> to rescue, also there are alternatives like hosting your own ftp/sftp file server but I won&rsquo;t consider them here!
So you probably already have a dedicated home file server running on Linux/BSD/Solaris that also has a torrent client installed on it that you access through web interface?</p>

<p>Oh you don&rsquo;t? Snap it&rsquo;s it&rsquo;s so useful that nowadays almost everyone has some kind of NAS that he/she is using for file storage and torrents.
So if you don&rsquo;t have one then you are behind of times</p>

<p>So what do we need to share some file over torrent? Yes indeed we need a torrent tracker</p>

<!-- more -->


<p><a href="http://thepiratebay.se"><img src="https://thepiratebay.se/static/img/tpb.jpg" alt="The Pirate Bay" /></a></p>

<p>You probably heard of the famous pirate bay arrr!&hellip; haven&rsquo;t you?
Well pirate bay has a torrent tracker and you don&rsquo;t. So you either have a choice and become a pirate bay resident and upload your torrent on their site
or you can host your own little pirate bay just for you and your friends only</p>

<p>Most torrent clients include torrent tracker functionality out of the box but let&rsquo;s consider our little case were we a have headless home server with torrent client
that has only web interface and no torrent tracker
So what do we do? We run our own standalone torrent tracker!</p>

<p>So that&rsquo;s how I&rsquo;ve ended on <a href="http://en.wikipedia.org/wiki/Comparison_of_BitTorrent_tracker_software">this page</a></p>

<p>My first choice was <a href="https://erdgeist.org/arts/software/opentracker/">opentracker</a> which is a very popular tracker that even pirate bay uses on their servers.
First thing I did I&rsquo;ve compiled and configured it in few mins and had it running on my <strong>6969</strong> port.
So the next thing I&rsquo;ve created a torrent with my torrent tracker announce url specified as **<a href="http://192.168.0.x:6969/announce**">http://192.168.0.x:6969/announce**</a> using <a href="http://mktorrent.sourceforge.net/">mktorrent</a>
and added it to my torrent client which started seeding it right away. The next step I&rsquo;ve created the same torrent file with announce url changed to my external ip and sent it to my friend!
My friend started his torrent client and added the torrent. He could see that it had one seeder but still couldn&rsquo;t download the file. Simple troubleshooting revealed that my torrent tracker
was listing my seeder peer with a local network ip address that my friend&rsquo;s torrent client couldn&rsquo;t connect to&hellip;</p>

<p><img src="http://i.imgur.com/TCYjoCe.jpg" alt="Crying Loli" /></p>

<p>I knew now what I needed from torrent tracker. My port was the same but my ip address should be external instead of internal.
I needed local ip substituted with remote ip for all external network peers. The peer port would remain the same since i have the same port forwarded.</p>

<p>Unfortunately I couldn&rsquo;t find any functionality in <a href="https://erdgeist.org/arts/software/opentracker/">opentracker</a> that would do that :(</p>

<p>So next thing I did I&rsquo;ve downloaded <a href="https://code.google.com/p/udpt/">udpt</a> and had it compiled.
It uses <a href="http://www.bittorrent.org/beps/bep_0015.html">udp tracker protocol</a> which is much more
network efficient. <a href="https://code.google.com/p/udpt/">udpt</a> is much more smaller than <a href="https://erdgeist.org/arts/software/opentracker/">opentracker</a>
in both source code and functionality and thus was ideal to experiment with.</p>

<p>Adding the needed functionality didn&rsquo;t solved my problem because udpt had some other bugs that I had to track down but in a few hours i had everything up and working!
In the end I had a fully working private torrent tracker that was doing what I was hoping for.
I&rsquo;ve even added code to run it as linux daemon thanks to <a href="http://www.netzmafia.de/skripten/unix/linux-daemon-howto.html">this little howto</a></p>

<p>My experimental fork is at <a href="https://github.com/troydm/udpt">this repository</a></p>

<p><img src="http://i.imgur.com/M6W7RfM.png" alt="Pirate Loli" /></p>

<p>Happy torrenting pirates!</p>
]]></content>
  </entry>
  
</feed>
